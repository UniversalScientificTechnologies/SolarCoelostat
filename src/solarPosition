#!/usr/bin/env python
# -*- coding: utf-8 -*-

import __init__
import os, sys
import math
import time, datetime
import rospy, rosparam
import std_msgs
import sensor_msgs
import geometry_msgs
import arom
from cv_bridge import CvBridge, CvBridgeError
from PyQt4 import QtGui
from PyQt4 import QtCore
from threading import Thread
import ids
import numpy as np
import cv2
#from __init__ import AromNode
from arom_helper import AromNode
import yaml
import zmq
import math


# http://jgiesen.de/sunrot/index.html


class sunpos(AromNode):
    node_name = "sun_position"
    node_type = "sun_position"

    def __init__(self):
        port = 8002

        AromNode.__init__(self)
        self.set_feature('hsfa_sunpos', {'port': port})
        self.image_pub = rospy.Publisher("image_topic", sensor_msgs.msg.Image, queue_size=1)
        self.image_pub2 = rospy.Publisher("image_topic2", sensor_msgs.msg.Image, queue_size=1)
        self.pub_error = rospy.Publisher("sun_err", geometry_msgs.msg.Point, queue_size=1)
        self.pub_pos = rospy.Publisher("sun_pos", geometry_msgs.msg.Point, queue_size=1)
        self.obs_name = rospy.Publisher("observation_name", std_msgs.msg.String, queue_size=1, latch = True)
        self.recording = False
        self.daymove_calib = False # tohle je normalne false. Pokud probiha kalibrace, tak true.
        self.daymove_old = None
        self.daymove_stage = 1 # vyhlazeno pro kalibraci pohybu
        self.angle = 0
        self.angleS = 0
        self.angle_axisA = 0
        self.angle_axisB = 90
        self.hold = False
        self.hold_time = time.time()
        self.record_pos = True
        self.recpos_time = time.time()
        rospy.Subscriber("image_target", geometry_msgs.msg.Point, self.newTarget)
        rospy.Subscriber("image_command", std_msgs.msg.String, self.getCommand)

        context = zmq.Context()
        self.socket = context.socket(zmq.PAIR)
        self.socket.connect("tcp://10.64.1.112:5556")

        self.bridge = CvBridge()
        self.LoadParamsFromConfig()

        #print (cv2.getBuildInformation())

        app = QtGui.QApplication(sys.argv)
        self.prepareSettingsWindow()


        self.cam = ids.Camera()
        #self.cam.color_mode = ids.ids_core.COLOR_RGB8    # Get images in RGB format
        self.cam.exposure = 0.01                            # Set initial exposure to 5ms
        self.cam.auto_exposure = False
        self.cam.continuous_capture = True
        img, meta = self.cam.next()

        cv2.namedWindow('Náhled pointační kamery', cv2.WINDOW_NORMAL)
        cv2.setMouseCallback("Náhled pointační kamery", self.onMouse)

        #cap = cv2.VideoCapture(0)
        #frame_counter = 0
        #cap.set(cv2.CAP_PROP_BRIGHTNESS,-100)
        #cap.set(cv2.CAP_PROP_CONTRAST,25)
        #self.center = (int(cap.get(3)/2), int(cap.get(4)/2)) # ziskat sirku a vysku obrazku
        self.center= (meta['width']/2,meta['height']/2)
        (centerx, centery) = self.center
        (cx, cy) = self.center
        diameter = 0
        self.sun_center = None
        self.target = self.center
        self.status = 0

                # None = 0
                # Stop = 1
                # Pause = 2
                # Start = 3

        day = datetime.datetime.now().timetuple().tm_yday
        self.sun_WE_angle = math.sin(((day+157)/235.24)*math.pi)*26.3
        #self.sun_WE_angle = -25
        self.sun_R = (180/math.pi)*(23.45*math.pi/180*math.sin(2*math.pi*(284+day)/(36.25)))
        self.sun_declinationAngle = self.sun_R + self.sun_WE_angle
        self.sun_appdiameter = 0.0 + 31/60.0 + 0/60.0
        print( "SolarDeclinationAngle:", self.sun_declinationAngle)
        print( "SolarAppierantDiameter:", self.sun_appdiameter)

        last_msg_neni_slunce = False

        while not rospy.is_shutdown():
            try:
                QtGui.QApplication.processEvents()

                #ret, frame = cap.read()
                img, meta = self.cam.next()
                #print meta
                frame = img


                #frame = cv2.fromarray(img)
                #cv2.imshow('frame', frame)
                if cv2.waitKey(1) & 0xFF == ord('q'):
                    break

                gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
                ret, thresh = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY)
                #cv2.imshow('gray',gray)
                #cv2.imshow('tresh',thresh)
                contours = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
                contours, hierarchy = contours
                #img, contours, hierarchy = contours
                cv2.drawContours(frame, contours, -1, (0,255,0), 3)
                (offx, offy) = self.target

                try:
                    valid = False
                    for i, cnt in enumerate(contours):
                        area = cv2.contourArea(cnt)
                        if area > 20000:
                            used_area = area
                            valid = True
                            print("-------------------------------")
                            diameter = int(math.sqrt(area/math.pi))*2 # prumer
                            print(area, diameter)
                            epsilon = 10*cv2.arcLength(cnt,True)
                            approx = cv2.approxPolyDP(cnt,epsilon,True)
                            M = cv2.moments(cnt)

                            cx = int(M['m10']/M['m00'])
                            cy = int(M['m01']/M['m00'])
                            self.sun_center = (cx, cy)
                            self.cente_point = (cx-centerx, cy-centery)
                            cpx, cpy = self.cente_point

                            ellipse = cv2.fitEllipse(cnt)
                            #print ellipse
                            cv2.ellipse(frame, ellipse, (10,10,225),2)       # vykresluje vypocitanou elipsu

                            print ((cx-offx, cy-offy))
                            (coel_errorx, coel_errory) = self.rotate(cx-offx, cy-offy, -self.angle_axisA)

                            #print((coel_errorx, coel_errory))

                            print('area', int(area))
                            cv2.circle(frame, self.sun_center, 5, (255, 10, 10), 1) # vykresluje stred slunce
                            cv2.putText(frame,'area: '+str(area), (cx,cy), cv2.FONT_HERSHEY_DUPLEX, 1.5,(120,120,120))
                            cv2.putText(frame,'Pos: ['+str(cx)+";"+str(cy)+"]", (cx,cy+32), cv2.FONT_HERSHEY_DUPLEX, 1.5,(120,120,120))
                            cv2.putText(frame,'Err: [%3f; %3f]'%(coel_errorx, coel_errory), (cx,cy+64), cv2.FONT_HERSHEY_DUPLEX, 1.5,(120,120,120))

                            cv2.line(frame, self.target, self.sun_center, (80, 80, 80))

                            # sever-jih
                            #ang = math.tan((self.angle+90)/180.0*math.pi)
                            #print(ang)

                            x1, y1, x2, y2 = self.get_line((cx,cy), self.angle, diameter)
                            cv2.line(frame, (x1, y1), (x2, y2), (200, 90, 90), 2)
                            cv2.putText(frame,'W', (x1, y1), cv2.FONT_HERSHEY_DUPLEX, 1.5,(120,120,120))
                            cv2.putText(frame,'E', (x2, y2), cv2.FONT_HERSHEY_DUPLEX, 1.5,(120,120,120))

                            x1, y1, x2, y2 = self.get_line((cx,cy), self.angle+90, diameter)
                            cv2.line(frame, (x1, y1), (x2, y2), (200, 90, 90), 2)

                            self.pos_rot = -1*math.atan2(centery-cy, centerx-cx)*180/math.pi
                            self.pos_dist = math.sqrt((centerx-cx)**2+(centery-cy)**2)/diameter/2

                            # Osa otaceni slunce (P-angle)
                            x1, y1, x2, y2 = self.get_line((cx,cy), self.angleS+self.angle+90, diameter*1.4)
                            cv2.line(frame, (x1, y1), (x2, y2), (90, 90, 200), 4)
                            cv2.putText(frame,'P-angle', (x1, y1), cv2.FONT_HERSHEY_DUPLEX, 1.5,(120,120,120))
                            cv2.putText(frame,'North', (x1, y1+30), cv2.FONT_HERSHEY_DUPLEX, 1.5,(120,120,120))
                            # Kolmice na osu otacine
                            x1, y1, x2, y2 = self.get_line((cx,cy), self.angleS, diameter)
                            cv2.line(frame, (x1, y1), (x2, y2), (90, 200, 90), 4)

                            # Osa otaceni (P-angle)
                            #ang = math.tan(self.angleS/180*math.pi)
                            #cv2.line(frame, (int(cx-1*diameter/2), int(cy+ang*diameter/2)), (int(cx+1*diameter/2), int(cy-ang*diameter/2)), (90, 90, 90), 3)
                            #cv2.putText(frame,'P', (int(cx-1*diameter/2), int(cy+ang*diameter/2)), cv2.FONT_HERSHEY_DUPLEX, 1.5,(120,120,120))

                            (rpx, rpy) = self.rotate(cpx, cpy, self.sun_declinationAngle)


                            self.ui_label_cam_coord.setText("rot: %3.3f dist: %3.3f <br>X: %3.3f; Y: %3.3f<br>X: %3.3f; Y: %3.3f<br><br>rotace: %s<br>SunLat: %s<br>SunLon: %s <br><br>WE angle: %.3f<br>SWE angle: %.3f <br> A: %3.3f B: %3.3f"
                                %(self.pos_rot, self.pos_dist, cpx, cpy, rpx, rpy, self.sun_declinationAngle, rpx, rpy/diameter*90, self.angle, self.angleS, self.angle_axisA, self.angle_axisB))

                    self.pub_error.publish(x = centerx - cx-offx, y = centery - cy-offy)
                    self.pub_pos.publish(x = cx, y = cy)

                    x1, y1, x2, y2 = self.get_line((centerx, centery), self.angle_axisA, 1000)
                    cv2.line(frame, (x1, y1), (x2, y2), (90, 90, 90), 4)
                    x1, y1, x2, y2 = self.get_line((centerx, centery), self.angle_axisB, 1000)
                    cv2.line(frame, (x1, y1), (x2, y2), (90, 90, 90), 4)

                    #print math.sqrt(area/math.pi)
                    cv2.circle(frame, self.sun_center, diameter/2, (200, 200, 10), 2)
                    cv2.circle(frame, self.center, 5, (200, 200, 10), 2)
                    cv2.circle(frame, self.target, 5, (255, 10, 10), 3)
                    cv2.putText(frame,'status: '+str(self.status),(10,20), cv2.FONT_HERSHEY_DUPLEX, 0.5,(120,120,120))

                    if self.recording:
                        directory = os.path.join("/mnt/data/", datetime.datetime.utcnow().strftime("%y-%m-%d"), "area", "Pointing")
                        if not os.path.exists(directory):
                            os.makedirs(directory)
                        print(directory+"/P_"+datetime.datetime.utcnow().strftime('%T')+'.png')
                        cv2.imwrite(directory+"/P_"+datetime.datetime.utcnow().strftime('%T')+'.png', gray)

                    if self.hold: # and int(area) > 200000:
                        if self.hold_time+1.5 < time.time():
                            if used_area > 200000:
                                self.hold_time = time.time()
                                print("chyba pozice je... {}px, {}px, send".format(coel_errorx, coel_errory))
                                msg_errx = coel_errorx
                                msg_erry = coel_errory
                                self.socket.send("chyba;1;{};{}".format(int(msg_errx), int(msg_erry)))
                                last_msg_neni_slunce = False
                            else:
                                print('Chyba pozice - neni dostatecne slunce...')
                                if not last_msg_neni_slunce:
                                    last_msg_neni_slunce = True
                                    self.socket.send("chyba;0;0;0")
                        else:
                            print("chyba pozice je... {}px, {}px".format(coel_errorx, coel_errory))

                    
                    if self.record_pos and self.recpos_time+2 <time.time():
                        self.recpos_time = time.time()
                        obsarea = rospy.get_param(self.node_name +"/spec_obsarea")
                        name = os.path.join("/mnt/data/", datetime.datetime.utcnow().strftime("%Y-%m-%d"), obsarea) + "/" + obsarea + datetime.datetime.now().strftime("_%Y-%m-%d" + ".pos")
                        directory = os.path.dirname(name)
                        if not os.path.exists(directory):
                            os.makedirs(directory)
                        with open(name, 'a+') as f:
                            f.write('{};{};{};{}\n'.format(time.time(), self.pos_rot, self.pos_dist, 0))
                    

                    if self.daymove_calib:
                        if not self.daymove_old:
                            self.btn_genmove.setStyleSheet("background-color: orange")
                            self.daymove_old = (cx,cy)
                            (ocx, ocy) = self.daymove_old
                            print("Nastavuji OLD polohu")
                            if self.daymove_stage == 1:
                                self.socket.send("timer;0")
                            elif self.daymove_stage == 2:
                                self.socket.send("moveA;1")
                            elif self.daymove_stage == 3:
                                self.socket.send("moveB;1")

                        dx = cx-ocx
                        dy = cy-ocy
                        delta = math.sqrt((dx)**2+(dy)**2)
                        angle = math.atan2(-dy, dx)/math.pi*180

                        '''
                        


                        '''

                        if self.daymove_stage == 1:
                            print("Vzdalenost time", delta)
                            if delta > 50:
                                print("Konec kalibrace")
                                self.socket.send("timer;1")
                                print(dx, dy)
                                self.angle = angle
                                #self.angleS= self.angle-(-25.2)
                                print("Uhel je", self.angle)
                                time.sleep(1)

                                self.daymove_old = None
                                self.daymove_stage = 2

                        elif self.daymove_stage == 2:
                            print("Vzdalenost v ose A", delta)
                            if delta > 50:
                                self.socket.send("moveA;0")
                                print(dx, dy)
                                self.angle_axisA = angle
                                print("Uhel je", self.angle_axisA)
                                time.sleep(1)

                                self.daymove_old = None
                                self.daymove_stage = 3

                        elif self.daymove_stage == 3:
                            print("Vzdalenost v ose B", delta)
                            if delta > 50:
                                self.socket.send("moveB;0")
                                print(dx, dy)
                                self.angle_axisB = angle
                                print("Uhel je", self.angle_axisB)
                                time.sleep(1)

                                self.daymove_calib = False
                                self.daymove_stage = 1
                                self.daymove_old = None
                                self.btn_genmove.setStyleSheet("background-color: green")

                        else:
                            self.daymove_stage = 1
                            self.daymove_old = None




                except Exception as e:
                    print("chyba", e)

                cv2.imshow("Náhled pointační kamery", frame)

                self.image_pub2.publish(self.bridge.cv2_to_imgmsg(thresh, "mono8"))
                self.image_pub.publish(self.bridge.cv2_to_imgmsg(frame, "bgr8"))

            except Exception as e:
                print(e)


    def getfilename(self):
        return  os.path.join("/mnt/data/", datetime.datetime.utcnow().strftime("%Y-%m-%d"), self.sun_area_edit.text(), "position") + "/" + self.sun_area_edit.text() + datetime.datetime.utcnow().strftime("_%Y%m%d" + ".hdf")


    def get_line(self, point, angle, length):
         x, y = point
         endy = length/2 * math.sin(math.radians(angle))
         endx = length/2 * math.cos(math.radians(angle))

         return int(x+endx), int(y-endy), int(x-endx), int(y+endy)

    def LoadParamsFromConfig(self):
        self.yaml_config_path = os.path.join(os.path.dirname(os.path.dirname(os.path.realpath(__file__))), 'config', self.node_name[1:]+".yaml")
        load_params = rosparam.load_file(self.yaml_config_path, self.node_name)
        for params, ns in load_params:
            rosparam.upload_params(ns,params)
        return load_params

    def rotate(self, x, y, rot):
        p1 = math.sqrt(x**2 + y**2)
        r1 = math.pi - math.atan2(y, x)
        # rs je uhel bodu (stredu slunce na kamere) na slunci vuci rovniku
        rs = r1+math.radians(rot)
        rpx = (p1*math.cos(rs))
        rpy = (p1*math.sin(rs))
        return (rpx, rpy)

    def onMouse(self, event,x,y,flags,param):
        if event == 1:
            print("ON mouse", event, x, y, flags, param)
            #target = object()
            self.newTarget((x,y))

    def newTarget(self, target):
        (csx, csy) = self.sun_center
        (cx, cy) = self.center
        tx = int(cx+(csx-target[0]))
        ty = int(cy+(csy-target[1]))
        print (tx, ty)
        print ("==========")
        self.target = (int(tx), int(ty))
        print (self.target)


    def setRecording(self, state):
        self.recording = bool(state)

    def setHold(self, hold):
        self.hold = bool(hold)
        if not self.hold:
            self.socket.send("chyba;0;0;0")

    def ExitApp(self):
        self.socket.send("chyba;0;0;0")
        rospy.signal_shutdown("closed by window")

    def target_actual(self):
        self.newTarget(self.center)

    def target_center(self):
        self.newTarget(self.sun_center)

    def set_exposure(self, val):
        print('set exposure', val)
        self.cam.exposure = float(val)

    def set_p_angle(self, val):
        print('set position angle', val)
        self.angleS = float(val)

    def set_observation_name(self, val):
        self.obs_name.publish(val)


    def prepareSettingsWindow(self):
        pass

        self.set_window = QtGui.QWidget()
        self.set_window.resize(250, 150)
        self.set_window.move(300, 300)
        self.set_window.setWindowTitle('Pointing camera')
        #ftself.set_window.setWindowIcon(QtGui.QIcon('/home/roman/arom_ws/src/SolarCoelostat/src/graphic/logo_pointing.png'))
        #self.set_window.show()

        #self.set_window.setWindowFlags(QtCore.Qt.WindowTitleHint)
        #self.set_window.setWindowFlags(QtCore.Qt.WindowStaysOnTopHint)


        mainLayout = QtGui.QVBoxLayout()
        self.set_window.setLayout(mainLayout)
        #self.set_window.closeEvent(self.ExitApp)

        integration = QtGui.QLineEdit(str(0.01))
        integration.setValidator(QtGui.QDoubleValidator())
        integration.textChanged.connect(lambda: self.set_exposure(float(integration.text())) )
        integration.setMaxLength(5)

        position = QtGui.QLineEdit(str(0.0))
        position.setValidator(QtGui.QDoubleValidator())
        position.textChanged.connect(lambda: self.set_p_angle(float(position.text())) )
        position.setMaxLength(7)

        self.sun_area_edit = QtGui.QLineEdit("sun_area")
        self.sun_area_edit.textChanged.connect(lambda: set_observation_name(self.sun_area_edit.text()))

        label = QtGui.QLabel('Integration time')

        comboBox = QtGui.QComboBox()
        comboBox.addItem("LIGHT")
        comboBox.addItem("LIGHT_TEST")
        comboBox.addItem("DARK")
        comboBox.addItem("BIAS")
        comboBox.addItem("none")
        comboBox.setCurrentIndex(rospy.get_param(self.node_name+"/spec_data_type",0))

        recording = QtGui.QCheckBox()
        recording.setText("Zaznamemnavani")
        recording.setCheckable(True)
        recording.setChecked(False)
        recording.toggled.connect(lambda:self.setRecording(recording.isChecked()))

        ploting = QtGui.QCheckBox()
        ploting.setText("plotting")
        ploting.setCheckable(True)
        ploting.setChecked(False)
        ploting.toggled.connect(lambda:self.setPlotting(ploting.isChecked()))
        
        hold = QtGui.QCheckBox()
        hold.setText("Drz pozici")
        hold.setCheckable(True)
        hold.setChecked(False)
        hold.toggled.connect(lambda:self.setHold(hold.isChecked()))

        btn_exit = QtGui.QPushButton('exit')
        btn_exit.clicked.connect(lambda:self.ExitApp())
        self.btn_genmove = QtGui.QPushButton('Zjistit denni pohyb')
        self.btn_genmove.clicked.connect(lambda:self.getMove())
        btn = QtGui.QPushButton('Pouzij parametry')
        btn.clicked.connect(lambda: self.updateFromWindow(integration, position, self.sun_area_edit, comboBox))
        btn_actual = QtGui.QPushButton('Drz soucastnou polohu')
        btn_actual.clicked.connect(lambda: self.target_actual())
        btn_center = QtGui.QPushButton('Drz stred')
        btn_center.clicked.connect(lambda: self.target_center())
        #btn.clicked.connect(lambda: (self.SC.setParameters(float(integration.text()), sun_area_edit.text(), comboBox.currentIndex())))

        self.ui_label_cam_coord = QtGui.QLabel("x: UNLL <br> Y: NULL")

        mainLayout.addWidget(btn_exit)
        mainLayout.addWidget(self.ui_label_cam_coord)
        mainLayout.addWidget(QtGui.QLabel("Pozicni uhel"))
        mainLayout.addWidget(position)
        mainLayout.addWidget(QtGui.QLabel("Integracni cas"))
        mainLayout.addWidget(integration)
        mainLayout.addWidget(QtGui.QLabel("Nazev pozorovani"))
        mainLayout.addWidget(self.sun_area_edit)
        mainLayout.addWidget(QtGui.QLabel("Typ dat"))
        mainLayout.addWidget(comboBox)
        mainLayout.addWidget(btn)
        mainLayout.addWidget(btn_actual)
        mainLayout.addWidget(btn_center)
        mainLayout.addWidget(self.btn_genmove)
        mainLayout.addWidget(recording)
        #mainLayout.addWidget(ploting)
        mainLayout.addWidget(hold)

        self.set_window.show()

    def distance(self, p0, p1, p2): # p3 is the point
        x0, y0 = p0
        x1, y1 = p1
        x2, y2 = p2
        nom = abs((y2 - y1) * x0 - (x2 - x1) * y0 + x2 * y1 - y2 * x1)
        denom = ((y2 - y1)**2 + (x2 - x1) ** 2) ** 0.5
        result = nom / denom
        return result

    def updateFromWindow(self, integration, position, sun_area_edit, comboBox):
        self.cam.exposure = float(integration.text())

        rospy.set_param(self.node_name +"/spec_inegration", float(integration.text()))
        rospy.set_param(self.node_name +"/spec_data_type", int(comboBox.currentIndex()))
        rospy.set_param(self.node_name +"/spec_obsarea", str(sun_area_edit.text()))

        #self.SC. float(integration.text())

        with open(self.yaml_config_path, 'w') as f:
            yaml.dump(rospy.get_param(self.node_name), f, default_flow_style=False)

    def getCommand(self, command):
        print (command)
        if command.data == 'start':
            self.status = 10

        if command.data == 'pause':
            self.status = 1

        if command.data == 'recenter':
            self.target = self.center

    def getMove(self):
        self.daymove_calib = True
        self.daymove_old = None
        #self.socket.send("timer;0")
        #time.sleep(5)
        #self.socket.send("timer;1")




if __name__ == '__main__':
    m = sunpos()
