#!/usr/bin/env python3
# -*- coding: utf-8 -*-

#from __init__ import AromNode
from arom_helper import AromNode
import __init__
import os, sys
import rospy, rosparam
import std_msgs
import sensor_msgs
import geometry_msgs
import arom
from cv_bridge import CvBridge, CvBridgeError



sys.path.remove('/opt/ros/kinetic/lib/python2.7/dist-packages')
#from cv_bridge import CvBridge, CvBridgeError
import math
import time, datetime
from PyQt5 import QtGui
from PyQt5 import QtCore
from PyQt5 import QtWidgets
from PyQt5.QtWidgets import QMainWindow, QApplication
from PyQt5.QtWidgets import (QWidget, QPushButton,
                             QHBoxLayout, QVBoxLayout, QApplication,
                             QLineEdit, QLabel, QComboBox, QCheckBox)
from threading import Thread
import ids
import numpy as np
import cv2
import yaml

import zmq
import math
import sunpy.coordinates


# http://jgiesen.de/sunrot/index.html


class sunpos(AromNode):
    node_name = "sun_position"
    node_type = "sun_position"

    def __init__(self):
        port = 8002

        AromNode.__init__(self)
        self.set_feature('hsfa_sunpos', {'port': port})
        #self.image_pub = rospy.Publisher("image_topic", sensor_msgs.msg.Image, queue_size=1)
        #self.image_pub2 = rospy.Publisher("image_topic2", sensor_msgs.msg.Image, queue_size=1)
        self.pub_error = rospy.Publisher("sun_err", geometry_msgs.msg.Point, queue_size=1)
        self.pub_pos_error = rospy.Publisher("pos_error", geometry_msgs.msg.Point, queue_size=1)
        self.pub_pos = rospy.Publisher("sun_pos", geometry_msgs.msg.Point, queue_size=1)
        self.obs_name = rospy.Publisher("observation_name", std_msgs.msg.String, queue_size=1, latch = True)
        self.recording = False
        self.daymove_calib = False # tohle je normalne false. Pokud probiha kalibrace, tak true.
        self.daymove_old = None
        self.daymove_stage = 1 # vyhlazeno pro kalibraci pohybu
        self.angle = 0
        self.set_p_angle()
        self.position_angle = sunpy.coordinates.get_sun_P().degree
        self.pos_rot = 0
        self.pos_dist = 0
        self.angle_axisA = 0
        self.angle_axisB = 90
        self.hold = False
        self.hold_time = time.time()
        self.record_pos = True
        self.recpos_time = time.time()
        rospy.Subscriber("image_target", geometry_msgs.msg.Point, self.newTarget)
        rospy.Subscriber("image_command", std_msgs.msg.String, self.getCommand)

        context = zmq.Context()
        self.socket = context.socket(zmq.PAIR)
        self.socket.connect("tcp://10.64.1.112:5556")

        self.bridge = CvBridge()
        self.LoadParamsFromConfig()

        #print (cv2.getBuildInformation())

        app = QApplication(sys.argv)
        self.prepareSettingsWindow()


        self.cam = ids.Camera()
        #self.cam.color_mode = ids.ids_core.COLOR_RGB8    # Get images in RGB format
        self.cam.exposure = 0.01                            # Set initial exposure to 5ms
        self.cam.auto_exposure = False
        self.cam.continuous_capture = True
        img, meta = self.cam.next()

        cv2.namedWindow("Pointing camera preview", cv2.WINDOW_NORMAL)
        cv2.setMouseCallback("Pointing camera preview", self.onMouse)

        #cap = cv2.VideoCapture(0)
        #frame_counter = 0
        #cap.set(cv2.CAP_PROP_BRIGHTNESS,-100)
        #cap.set(cv2.CAP_PROP_CONTRAST,25)
        #self.center = (int(cap.get(3)/2), int(cap.get(4)/2)) # ziskat sirku a vysku obrazku
        self.center= (int(meta['width']/2), int(meta['height']/2))
        (centerx, centery) = self.center
        (cx, cy) = self.center
        diameter = 0
        self.sun_center = None
        self.target = self.center
        self.status = 0

                # None = 0
                # Stop = 1
                # Pause = 2
                # Start = 3

        day = datetime.datetime.now().timetuple().tm_yday
        self.sun_WE_angle = math.sin(((day+157)/235.24)*math.pi)*26.3
        #self.sun_WE_angle = -25
        self.sun_R = (180/math.pi)*(23.45*math.pi/180*math.sin(2*math.pi*(284+day)/(36.25)))
        self.sun_declinationAngle = self.sun_R + self.sun_WE_angle
        self.sun_appdiameter = 0.0 + 31/60.0 + 0/60.0
        print( "SolarDeclinationAngle:", self.sun_declinationAngle)
        print( "SolarAppierantDiameter:", self.sun_appdiameter)

        last_msg_neni_slunce = False
  

        while not rospy.is_shutdown():
            try:
                QApplication.processEvents()
                time.sleep(0.1)

                img, meta = self.cam.next()
                frame = img

                if cv2.waitKey(1) & 0xFF == ord('q'):
                    break

                gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
                ret, thresh = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY)
                contours = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
                contours, hierarchy = contours
                cv2.drawContours(frame, contours, -1, (0,255,0), 3)
                (offx, offy) = self.target

             # Nastav pozicni uhel automaticky
                p_ang = self.set_p_angle()
                self.position.setText("{}".format(p_ang))

                try:
                    valid = False
                    for i, cnt in enumerate(contours):
                        area = cv2.contourArea(cnt)
                        if area > 20000:
                            used_area = area
                            valid = True
                            print("-------------------------------")
                            diameter = int(math.sqrt(area/math.pi))*2 # prumer
                            # print("Area: {}, Diameter: {}".format(area,diameter))
                            epsilon = 10*cv2.arcLength(cnt,True)
                            approx = cv2.approxPolyDP(cnt,epsilon,True)
                            M = cv2.moments(cnt)

                            cx = int(M['m10']/M['m00']) # stredy slunecnich disku
                            cy = int(M['m01']/M['m00'])
                            self.sun_center = (cx, cy)
                            self.center_point = (cx-centerx, cy-centery) # vzdalenost stredu sluce od stredu kamery
                            cpx, cpy = self.center_point

                            ellipse = cv2.fitEllipse(cnt)
                            #print ellipse
                            cv2.ellipse(frame, ellipse, (10,10,225),2)       # vykresluje vypocitanou elipsu

                            # print("chyba", (cx-offx, cy-offy))
                            (coel_errorx, coel_errory) = self.rotate(cx-offx, cy-offy, -self.angle_axisA)

                            # print("chyba px", (coel_errorx, coel_errory))

                            cv2.circle(frame, self.sun_center, 5, (255, 10, 10), 1) # vykresluje stred slunce
                            cv2.putText(frame,'area: '+str(area), (cx,cy-2), cv2.FONT_HERSHEY_DUPLEX, 1.5,(120,120,120))
                            cv2.putText(frame,'Pos: ['+str(cx)+";"+str(cy)+"]", (cx,cy+35), cv2.FONT_HERSHEY_DUPLEX, 1.5,(120,120,120))
                            cv2.putText(frame,'Err: [%3f; %3f]'%(coel_errorx, coel_errory), (cx,cy+75), cv2.FONT_HERSHEY_DUPLEX, 1.5,(120,120,120))

                            cv2.line(frame, self.target, self.sun_center, (80, 80, 80))

                            # sever-jih
                            #ang = math.tan((self.angle+90)/180.0*math.pi)
                            #print(ang)

                            # Denni pohyb slunce
                            x1, y1, x2, y2 = self.get_line((cx,cy), self.angle, diameter)
                            cv2.line(frame, (x1, y1), (x2, y2), (200, 90, 90), 2)
                            cv2.putText(frame,'W', (x1, y1), cv2.FONT_HERSHEY_DUPLEX, 1.5,(120,120,120))
                            cv2.putText(frame,'E', (x2, y2), cv2.FONT_HERSHEY_DUPLEX, 1.5,(120,120,120))

                            #x1, y1, x2, y2 = self.get_line((cx,cy), self.angle+90, diameter)
                            #cv2.line(frame, (x1, y1), (x2, y2), (200, 90, 90), 2)

                            self.pos_rot = -1*math.atan2(centery-cy, centerx-cx)*180/math.pi
                            self.pos_dist = math.sqrt((centerx-cx)**2+(centery-cy)**2)/diameter/2

                            # Osa otaceni slunce (P-angle)
                            x1, y1, x2, y2 = self.get_line((cx,cy), self.position_angle+self.angle+90, diameter*1.3)
                            cv2.line(frame, (x1, y1), (x2, y2), (90, 90, 200), 3)
                            cv2.putText(frame,'P-angle', (x1, y1), cv2.FONT_HERSHEY_DUPLEX, 1.5,(120,120,120))
                            cv2.putText(frame,'North', (x1, y1+30), cv2.FONT_HERSHEY_DUPLEX, 1.5,(120,120,120))
                            # Kolmice na osu otacine
                            x1, y1, x2, y2 = self.get_line((cx,cy), self.position_angle+self.angle, diameter)
                            cv2.line(frame, (x1, y1), (x2, y2), (90, 90, 200), 3)

                            # Osa otaceni (P-angle)
                            #ang = math.tan(self.position_angle/180*math.pi)
                            #cv2.line(frame, (int(cx-1*diameter/2), int(cy+ang*diameter/2)), (int(cx+1*diameter/2), int(cy-ang*diameter/2)), (90, 90, 90), 3)
                            #cv2.putText(frame,'P', (int(cx-1*diameter/2), int(cy+ang*diameter/2)), cv2.FONT_HERSHEY_DUPLEX, 1.5,(120,120,120))

                            x1, y1, x2, y2 = self.get_line((cx,cy), self.angle_axisA, diameter)
                            cv2.line(frame, (x1, y1), (x2, y2), (20, 20, 20), 1)
                            x1, y1, x2, y2 = self.get_line((cx,cy), self.angle_axisB, diameter)
                            cv2.line(frame, (x1, y1), (x2, y2), (20, 20, 20), 1)


                            (rpx, rpy) = self.rotate(cpx, cpy, self.sun_declinationAngle)

                            #print(self.pos_rot)

                            text = "rot:{:6.2f}, dist:{:6.2f}<br>".format(self.pos_rot,self.pos_dist)
                            text+= "<br>Poloha vuci stredu kamery<br> [{:5f},{:5f}]".format(cpx,cpy)
                            # text+= "<br>V souradnicich kamery<br> [{:5f},{:5f}]".format(cpx,cpy)
                            text+= "<br>Uhly os [time, az, alt]: <br>{:6.2f}, {:6.2f}, {:6.2f}".format(self.angle, self.angle_axisA, self.angle_axisB)
                            text+= "<br>V souradnicich coelostatu<br> [{:6.2f},{:6.2f}]<br>".format(rpx,rpy)
                            text+= "<br>Rotace: {:6.2f}".format(self.sun_declinationAngle)
                            text+= "<br>Lat {:6.2f}, Lon {:6.2f}".format(rpx, rpy/diameter*90)
                            #text+= "<br>Rotace: {self.sun_declinationAngle},<br> SunLon: {}".format()

                            #self.ui_label_cam_coord.setText("rot: %3.3f dist: %3.3f <br>Poloha stredu Slunce oproti strudu kamery<br>V souradnicich kameryX: %3.3f; Y: %3.3f<br>"+
                            #    "V souradnicich coelostatu:<br>X: %3.3f; Y: %3.3f<br><br>rotace: %s<br>SunLat: %s<br>SunLon: %s <br><br>WE angle: %.3f<br>SWE angle: %.3f <br> A: %3.3f B: %3.3f"
                            #    %(self.pos_rot, self.pos_dist, cpx, cpy, rpx, rpy, self.sun_declinationAngle, rpx, rpy/diameter*90, self.angle, self.position_angle, self.angle_axisA, self.angle_axisB))
                            self.ui_label_cam_coord.setText(text)

                            self.pub_error.publish(x = int(centerx - cx-offx), y = int(centery - cy-offy))
                            self.pub_pos_error.publish(x = int(coel_errorx), y = int(coel_errory))
                            self.pub_pos.publish(x = int(cx), y = int(cy), z = int(area))

                    
                    cv2.circle(frame, self.sun_center, int(diameter/2), (200, 200, 10), 2)
                    cv2.circle(frame, self.center, 20, (0, 200, 0), 3)
                    cv2.circle(frame, self.target, 5, (255, 10, 10), 3)
                    cv2.putText(frame,'status: '+str(self.status),(10,20), cv2.FONT_HERSHEY_DUPLEX, 0.5,(120,120,120))

                    print("recording",self.recording)
                    if self.recording:
                        directory = os.path.join("/mnt/data/", datetime.datetime.utcnow().strftime("%y-%m-%d"), "area", "Pointing")
                        if not os.path.exists(directory):
                            os.makedirs(directory)
                        print(directory+"/P_"+datetime.datetime.utcnow().strftime('%T')+'.png')
                        cv2.imwrite(directory+"/P_"+datetime.datetime.utcnow().strftime('%T')+'.png', gray)

                    print("Hold:", self.hold)
                    if self.hold: # and int(area) > 200000:
                        if self.hold_time+1.5 < time.time():
                            if used_area > 200000:
                                self.hold_time = time.time()
                                print("chyba pozice je... {}px, {}px, send".format(coel_errorx, coel_errory))
                                msg_errx = coel_errorx
                                msg_erry = coel_errory
                                self.socket.send_string("chyba;1;{};{}".format(int(msg_errx), int(msg_erry)))
                                last_msg_neni_slunce = False
                            else:
                                print('Chyba pozice - neni dostatecne slunce...')
                                if not last_msg_neni_slunce:
                                    last_msg_neni_slunce = True
                                    self.socket.send_string("chyba;0;0;0")
                        else:
                            print("chyba pozice je... {}px, {}px".format(coel_errorx, coel_errory))

                    print("Self record pos")
                    if self.record_pos and self.recpos_time+2 <time.time():
                        self.recpos_time = time.time()
                        obsarea = rospy.get_param(self.node_name +"/spec_obsarea")
                        name = os.path.join("/mnt/data/", datetime.datetime.utcnow().strftime("%Y-%m-%d"), obsarea) + "/" + obsarea + datetime.datetime.now().strftime("_%Y-%m-%d" + ".pos")
                        directory = os.path.dirname(name)
                        if not os.path.exists(directory):
                            os.makedirs(directory)
                        with open(name, 'a+') as f:
                            f.write('{};{};{};{}\n'.format(time.time(), self.pos_rot, self.pos_dist, 0))
                    
                    print("daymove_calib", self.daymove_calib)
                    if self.daymove_calib:
                        if not self.daymove_old:
                            self.btn_genmove.setStyleSheet("background-color: orange")
                            self.daymove_old = (cx,cy)
                            (ocx, ocy) = self.daymove_old
                            print("Nastavuji OLD polohu")
                            if self.daymove_stage == 1:
                                self.socket.send_string("timer;0")
                            elif self.daymove_stage == 2:
                                self.socket.send_string("moveA;-1")
                            elif self.daymove_stage == 3:
                                self.socket.send_string("moveB;1")

                        dx = cx-ocx
                        dy = cy-ocy
                        delta = math.sqrt((dx)**2+(dy)**2)
                        angle = math.atan2(-dy, dx)/math.pi*180


                        if self.daymove_stage == 1:
                            print("Vzdalenost time", delta)
                            if delta > 100:
                                print("Konec kalibrace")
                                self.socket.send_string("timer;1")
                                print(dx, dy)
                                self.angle = angle
                                #self.position_angle= self.angle-(-25.2)
                                print("Uhel je", self.angle)
                                time.sleep(0.5)

                                self.daymove_old = None
                                self.daymove_stage = 2

                        elif self.daymove_stage == 2:
                            print("Vzdalenost v ose A", delta)
                            if delta > 100:
                                self.socket.send_string("moveA;0")
                                print(dx, dy)
                                self.angle_axisA = 180+angle
                                print("Uhel je", self.angle_axisA)
                                time.sleep(0.5)

                                self.daymove_old = None
                                self.daymove_stage = 3

                        elif self.daymove_stage == 3:
                            print("Vzdalenost v ose B", delta)
                            if delta > 100:
                                self.socket.send_string("moveB;0")
                                print(dx, dy)
                                self.angle_axisB = angle
                                print("Uhel je", self.angle_axisB)
                                time.sleep(0.5)

                                self.daymove_calib = False
                                self.daymove_stage = 1
                                self.daymove_old = None
                                self.btn_genmove.setStyleSheet("background-color: green")

                        else:
                            self.daymove_stage = 1
                            self.daymove_old = None



                except Exception as e:
                    print("chyba", e)

                cv2.imshow("Pointing camera preview", frame)

                #self.image_pub2.publish(self.bridge.cv2_to_imgmsg(thresh, "mono8"))
                #self.image_pub.publish(self.bridge.cv2_to_imgmsg(frame, "bgr8"))

            except Exception as e:
                print(e)


    def getfilename(self):
        return  os.path.join("/mnt/data/", datetime.datetime.utcnow().strftime("%Y-%m-%d"), self.sun_area_edit.text(), "position") + "/" + self.sun_area_edit.text() + datetime.datetime.utcnow().strftime("_%Y%m%d" + ".hdf")


    def get_line(self, point, angle, length):
         x, y = point
         endy = length/2 * math.sin(math.radians(angle))
         endx = length/2 * math.cos(math.radians(angle))

         return int(x+endx), int(y-endy), int(x-endx), int(y+endy)

    def LoadParamsFromConfig(self):
        self.yaml_config_path = os.path.join(os.path.dirname(os.path.dirname(os.path.realpath(__file__))), 'config', self.node_name[1:]+".yaml")
        load_params = rosparam.load_file(self.yaml_config_path, self.node_name)
        for params, ns in load_params:
            rosparam.upload_params(ns,params)
        return load_params

    def rotate(self, x, y, rot):
        print("rotace")
        p1 = math.sqrt(x**2 + y**2)
        r1 = math.pi - math.atan2(y, x)
        # rs je uhel bodu (stredu slunce na kamere) na slunci vuci rovniku
        rs = r1+math.radians(rot)
        rpx = (p1*math.cos(rs))
        rpy = (p1*math.sin(rs))
        return (rpx, rpy)

    def onMouse(self, event,x,y,flags,param):
        if event == 1:
            print("ON mouse", event, x, y, flags, param)
            #target = object()
            self.newTarget((x,y))

    def newTarget(self, target):
        (csx, csy) = self.sun_center
        (cx, cy) = self.center
        tx = int(cx+(csx-target[0]))
        ty = int(cy+(csy-target[1]))
        print (tx, ty)
        print ("==========")
        self.target = (int(tx), int(ty))
        print (self.target)


    def setRecording(self, state):
        self.recording = bool(state)

    def setHold(self, hold):
        self.hold = bool(hold)
        if not self.hold:
            self.socket.send_string("chyba;0;0;0")

    def ExitApp(self):
        self.socket.send_string("chyba;0;0;0")
        rospy.signal_shutdown("closed by window")

    def target_actual(self):
        self.newTarget(self.center)

    def target_center(self):
        self.newTarget(self.sun_center)

    def set_exposure(self, val):
        print('set exposure', val)
        self.cam.exposure = float(val)

    def set_p_angle(self, val = None):
        if not val:
            value = sunpy.coordinates.get_sun_P().degree
        else:
            value = val
        self.position_angle = float(value)
        return float(value)

    def set_observation_name(self, val):
        self.obs_name.publish(val)


    def prepareSettingsWindow(self):
        pass

        self.set_window = QWidget()
        self.set_window.resize(250, 150)
        self.set_window.move(300, 300)
        self.set_window.setWindowTitle('Pointing camera')
        #ftself.set_window.setWindowIcon(QIcon('/home/roman/arom_ws/src/SolarCoelostat/src/graphic/logo_pointing.png'))
        #self.set_window.show()

        #self.set_window.setWindowFlags(QtCore.Qt.WindowTitleHint)
        #self.set_window.setWindowFlags(QtCore.Qt.WindowStaysOnTopHint)


        mainLayout = QVBoxLayout()
        self.set_window.setLayout(mainLayout)
        #self.set_window.closeEvent(self.ExitApp)

        integration = QLineEdit(str(0.01))
        integration.setValidator(QtGui.QDoubleValidator())
        integration.textChanged.connect(lambda: self.set_exposure(float(integration.text())) )
        integration.setMaxLength(5)

        self.position = QLineEdit(str(0.0))
        self.position.setValidator(QtGui.QDoubleValidator())
        #self.position.textChanged.connect(lambda: self.set_p_angle(float(self.position.text())) )
        #self.position.setMaxLength(7)

        self.sun_area_edit = QLineEdit("sun_area")
        self.sun_area_edit.textChanged.connect(lambda: set_observation_name(self.sun_area_edit.text()))

        label = QLabel('Integration time')

        comboBox = QComboBox()
        comboBox.addItem("LIGHT")
        comboBox.addItem("LIGHT_TEST")
        comboBox.addItem("DARK")
        comboBox.addItem("BIAS")
        comboBox.addItem("none")
        comboBox.setCurrentIndex(rospy.get_param(self.node_name+"/spec_data_type",0))

        recording = QCheckBox()
        recording.setText("Zaznamemnavani")
        recording.setCheckable(True)
        recording.setChecked(False)
        recording.toggled.connect(lambda:self.setRecording(recording.isChecked()))

        ploting = QCheckBox()
        ploting.setText("plotting")
        ploting.setCheckable(True)
        ploting.setChecked(False)
        ploting.toggled.connect(lambda:self.setPlotting(ploting.isChecked()))
        
        hold = QCheckBox()
        hold.setText("Drz pozici")
        hold.setCheckable(True)
        hold.setChecked(False)
        hold.toggled.connect(lambda:self.setHold(hold.isChecked()))

        btn_exit = QPushButton('exit')
        btn_exit.clicked.connect(lambda:self.ExitApp())
        self.btn_genmove = QPushButton('Zjistit denni pohyb')
        self.btn_genmove.clicked.connect(lambda:self.getMove())
        btn = QPushButton('Pouzij parametry')
        btn.clicked.connect(lambda: self.updateFromWindow(integration, self.position, self.sun_area_edit, comboBox))
        btn_actual = QPushButton('Drz soucasnou polohu')
        btn_actual.clicked.connect(lambda: self.target_actual())
        btn_center = QPushButton('Drz stred')
        btn_center.clicked.connect(lambda: self.target_center())
        #btn.clicked.connect(lambda: (self.SC.setParameters(float(integration.text()), sun_area_edit.text(), comboBox.currentIndex())))

        self.ui_label_cam_coord = QLabel("x: UNLL <br> Y: NULL")

        mainLayout.addWidget(btn_exit)
        mainLayout.addWidget(self.ui_label_cam_coord)
        mainLayout.addWidget(QLabel("Pozicni uhel"))
        mainLayout.addWidget(self.position)
        mainLayout.addWidget(QLabel("Integracni cas"))
        mainLayout.addWidget(integration)
        mainLayout.addWidget(QLabel("Nazev pozorovani"))
        mainLayout.addWidget(self.sun_area_edit)
        mainLayout.addWidget(QLabel("Typ dat"))
        mainLayout.addWidget(comboBox)
        mainLayout.addWidget(btn)
        mainLayout.addWidget(btn_actual)
        mainLayout.addWidget(btn_center)
        mainLayout.addWidget(self.btn_genmove)
        mainLayout.addWidget(recording)
        #mainLayout.addWidget(ploting)
        mainLayout.addWidget(hold)

        self.set_window.show()

    def distance(self, p0, p1, p2): # p3 is the point
        x0, y0 = p0
        x1, y1 = p1
        x2, y2 = p2
        nom = abs((y2 - y1) * x0 - (x2 - x1) * y0 + x2 * y1 - y2 * x1)
        denom = ((y2 - y1)**2 + (x2 - x1) ** 2) ** 0.5
        result = nom / denom
        return result

    def updateFromWindow(self, integration, position, sun_area_edit, comboBox):
        self.cam.exposure = float(integration.text())

        rospy.set_param(self.node_name +"/spec_inegration", float(integration.text()))
        rospy.set_param(self.node_name +"/spec_data_type", int(comboBox.currentIndex()))
        rospy.set_param(self.node_name +"/spec_obsarea", str(sun_area_edit.text()))

        #self.SC. float(integration.text())

        with open(self.yaml_config_path, 'w') as f:
            yaml.dump(rospy.get_param(self.node_name), f, default_flow_style=False)

    def getCommand(self, command):
        print (command)
        if command.data == 'start':
            self.status = 10

        if command.data == 'pause':
            self.status = 1

        if command.data == 'recenter':
            self.target = self.center

    def getMove(self):
        self.daymove_calib = True
        self.daymove_old = None
        #self.socket.send_string("timer;0")
        #time.sleep(5)
        #self.socket.send_string("timer;1")




if __name__ == '__main__':
    m = sunpos()
