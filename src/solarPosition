#!/usr/bin/env python
# -*- coding: utf-8 -*-

import __init__
import os, sys
import math
import time, datetime
import rospy, rosparam
import std_msgs
import sensor_msgs
import geometry_msgs
import arom
from cv_bridge import CvBridge, CvBridgeError
from PyQt4 import QtGui
from PyQt4 import QtCore
from threading import Thread
import ids
import numpy as np
import cv2
#from __init__ import AromNode
from arom_helper import AromNode


# http://jgiesen.de/sunrot/index.html


class sunpos(AromNode):
    node_name = "sun_position"
    node_type = "sun_position"

    def __init__(self):
        port = 8002

        AromNode.__init__(self)
        self.set_feature('hsfa_sunpos', {'port': port})
        self.image_pub = rospy.Publisher("image_topic", sensor_msgs.msg.Image, queue_size=1)
        self.image_pub2 = rospy.Publisher("image_topic2", sensor_msgs.msg.Image, queue_size=1)
        self.pub_error = rospy.Publisher("sun_err", geometry_msgs.msg.Point, queue_size=1)
        self.pub_pos = rospy.Publisher("sun_pos", geometry_msgs.msg.Point, queue_size=1)
        rospy.Subscriber("image_target", geometry_msgs.msg.Point, self.newTarget)
        rospy.Subscriber("image_command", std_msgs.msg.String, self.getCommand)

        self.bridge = CvBridge()
        self.LoadParamsFromConfig()
        
        #print (cv2.getBuildInformation())

        app = QtGui.QApplication(sys.argv)
        self.prepareSettingsWindow()
    

        cam = ids.Camera()
        #cam.color_mode = ids.ids_core.COLOR_RGB8    # Get images in RGB format
        cam.exposure = 500                            # Set initial exposure to 5ms
        cam.auto_exposure = False
        cam.continuous_capture = True  

        cv2.namedWindow('plot', cv2.WINDOW_NORMAL)
        cv2.setMouseCallback("plot", self.onMouse)

        #cap = cv2.VideoCapture(0)
        #frame_counter = 0
        #cap.set(cv2.CAP_PROP_BRIGHTNESS,-100)
        #cap.set(cv2.CAP_PROP_CONTRAST,25)
        #self.center = (int(cap.get(3)/2), int(cap.get(4)/2)) # ziskat sirku a vysku obrazku
        self.center= (100,100)
        (centerx, centery) = self.center
        self.sun_center = None
        self.target = self.center
        self.status = 0

                # None = 0
                # Stop = 1
                # Pause = 2
                # Start = 3

        day = datetime.datetime.now().timetuple().tm_yday
        self.sun_WE_angle = 30.0
        self.sun_R =  (180/math.pi)*(23.45*math.pi/180*math.sin(2*math.pi*(284+day)/(36.25)))
        self.sun_declinationAngle = self.sun_R + self.sun_WE_angle
        self.sun_appdiameter = 0.0 + 31/60.0 + 0/60.0
        print( "SolarDeclinationAngle:", self.sun_declinationAngle)
        print( "SolarAppierantDiameter:", self.sun_appdiameter)
        
        while not rospy.is_shutdown():
            try:
                QtGui.QApplication.processEvents()

                #ret, frame = cap.read()
                img, meta = cam.next()
                print meta
                print img
                frame = img

                cv2.imshow("plot", frame)

                #frame = cv2.fromarray(img)
                #cv2.imshow('frame', frame)
                if cv2.waitKey(1) & 0xFF == ord('q'):
                    break

                gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
                ret, thresh = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY)
                #cv2.imshow('gray',gray)
                #cv2.imshow('tresh',thresh)
                contours = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)                
                #contours, hierarchy = contours
                img, contours, hierarchy = contours
                cv2.drawContours(frame, contours, -1, (0,255,0), 3)
                (offx, offy) = self.target

                try:
                    for i, cnt in enumerate(contours):
                        area = cv2.contourArea(cnt)
                        if area > 20000:
                            print "-------------------------------"
                            diameter = int(math.sqrt(area/math.pi))*2
                            print area, diameter
                            epsilon = 10*cv2.arcLength(cnt,True)
                            approx = cv2.approxPolyDP(cnt,epsilon,True)
                            M = cv2.moments(cnt)

                            cx = int(M['m10']/M['m00'])
                            cy = int(M['m01']/M['m00'])
                            self.sun_center = (cx, cy)
                            self.cente_point = (cx-centerx, cy-centery)
                            cpx, cpy = self.cente_point

                            ellipse = cv2.fitEllipse(cnt)
                            #print ellipse
                            cv2.ellipse(frame, ellipse, (10,10,225),2)       # vykresluje vypocitanou elipsu

                            print ">>"
                            print ((cx-offx, cy-offy))
                            (coel_errorx, coel_errory) = self.rotate(cx-offx, cy-offy, -self.sun_declinationAngle)
                            print((coel_errorx, coel_errory))

                            cv2.circle(frame, self.sun_center, 5, (255, 10, 10), 1) # vykresluje stred slunce
                            cv2.putText(frame,'area: '+str(area),(cx,cy), cv2.FONT_HERSHEY_DUPLEX, 0.5,(120,120,120))
                            cv2.putText(frame,'pos: ['+str(cx)+";"+str(cy)+"]",(cx,cy+20), cv2.FONT_HERSHEY_DUPLEX, 0.5,(120,120,120))
                            cv2.putText(frame,'Merr: [%3f; %3f]'%(coel_errorx, coel_errory),(cx,cy+40), cv2.FONT_HERSHEY_DUPLEX, 0.5,(120,120,120))

                            cv2.line(frame, self.target, self.sun_center, (80, 80, 80))

                            ang = math.tan((self.sun_declinationAngle+90)*math.pi/180)
                            cv2.line(frame, (int(cx-1*diameter/2), int(cy+ang*diameter/2)), (int(cx+1*diameter/2), int(cy-ang*diameter/2)), (255, 100, 100), 1)
                            ang = math.tan((self.sun_declinationAngle)*math.pi/180)
                            cv2.line(frame, (int(cx-1*diameter/2), int(cy+ang*diameter/2)), (int(cx+1*diameter/2), int(cy-ang*diameter/2)), (255, 100, 100), 1)
                            ang = math.tan((self.sun_WE_angle)*math.pi/180)
                            cv2.line(frame, (int(cx-1*diameter/2), int(cy+ang*diameter/2)), (int(cx+1*diameter/2), int(cy-ang*diameter/2)), (80, 90, 90), 1)
                

                            (rpx, rpy) = self.rotate(cpx, cpy, self.sun_declinationAngle)
                            

                            self.ui_label_cam_coord.setText("X:%3.3f; Y:%3.3f<br>X:%3.3f Y:%3.3f<br>rotace: %s<br>SunLat: %s<br>SunLon: %s" 
                                %(cpx, cpy, rpx, rpy, self.sun_declinationAngle, rpx, rpy/diameter*90))

                    self.pub_error.publish(x = centerx - cx-offx, y = centery - cy-offy)
                    self.pub_pos.publish(x = cx, y = cy)
                    angle_y = math.tan(self.sun_WE_angle*math.pi/180)
                    length = 1000
                    cv2.line(frame, (int(centerx-1*length), int(centery+angle_y*length)), (int(centerx+1*length), int(centery-angle_y*length)), (80, 80, 80), 1)

                    #print math.sqrt(area/math.pi)
                    cv2.circle(frame, self.sun_center, diameter/2, (200, 200, 10), 2)
                    cv2.circle(frame, self.center, 5, (200, 200, 10), 2)
                    cv2.circle(frame, self.target, 5, (255, 10, 10), 3)
                    cv2.putText(frame,'status: '+str(self.status),(10,20), cv2.FONT_HERSHEY_DUPLEX, 0.5,(120,120,120))
       
                except Exception as e:
                    print("chyba", e)
                                
                self.image_pub2.publish(self.bridge.cv2_to_imgmsg(thresh, "mono8"))
                self.image_pub.publish(self.bridge.cv2_to_imgmsg(frame, "bgr8"))

            except Exception as e:
                print(e)


    def LoadParamsFromConfig(self):
        self.yaml_config_path = os.path.join(os.path.dirname(os.path.dirname(os.path.realpath(__file__))), 'config', self.node_name[1:]+".yaml")
        load_params = rosparam.load_file(self.yaml_config_path, self.node_name)
        for params, ns in load_params:
            rosparam.upload_params(ns,params)
        return load_params

    def rotate(self, x, y, rot):
        p1 = math.sqrt(x**2 + y**2)
        r1 = math.pi - math.atan2(y, x)
        # rs je uhel bodu (stredu slunce na kamere) na slunci vuci rovniku
        rs = r1+math.radians(rot)
        rpx = (p1*math.cos(rs))
        rpy = (p1*math.sin(rs))
        return (rpx, rpy)

    def onMouse(self, event,x,y,flags,param):
        if event == 1:
            print("ON mouse", event, x, y, flags, param)

            target = object()
            self.newTarget((x,y))

    def newTarget(self, target):
        (csx, csy) = self.sun_center
        (cx, cy) = self.center
        tx = int(cx+(csx-target[0]))
        ty = int(cy+(csy-target[1]))
        print (tx, ty)
        print ("==========")
        self.target = (int(tx), int(ty))
        print (self.target)



    def ExitApp(self):
        rospy.signal_shutdown("closed by window")

    def prepareSettingsWindow(self):
        pass

        self.set_window = QtGui.QWidget()
        self.set_window.resize(250, 150)
        self.set_window.move(300, 300)
        self.set_window.setWindowTitle('Simple')
        #self.set_window.show()

        #self.set_window.setWindowFlags(QtCore.Qt.WindowTitleHint)
        #self.set_window.setWindowFlags(QtCore.Qt.WindowStaysOnTopHint)

        
        mainLayout = QtGui.QVBoxLayout()
        self.set_window.setLayout(mainLayout)
        #self.set_window.closeEvent(self.ExitApp)

        integration = QtGui.QLineEdit(str(100))
        integration.setValidator(QtGui.QIntValidator())
        integration.setMaxLength(4)

        sun_area_edit = QtGui.QLineEdit("sun_area")


        label = QtGui.QLabel('Integration time')

        comboBox = QtGui.QComboBox()
        comboBox.addItem("LIGHT")
        comboBox.addItem("LIGHT_TEST")
        comboBox.addItem("DARK")
        comboBox.addItem("BIAS")
        comboBox.addItem("none")
        comboBox.setCurrentIndex(rospy.get_param(self.node_name+"/spec_data_type",0))

        recording = QtGui.QCheckBox()
        recording.setText("recording")
        recording.setCheckable(True)
        recording.setChecked(True)
        recording.toggled.connect(lambda:self.SC.setRecording(recording.isChecked()))

        ploting = QtGui.QCheckBox()
        ploting.setText("plotting")
        ploting.setCheckable(True)
        ploting.setChecked(True)
        ploting.toggled.connect(lambda:self.setPlotting(ploting.isChecked()))


        btn_exit = QtGui.QPushButton('exit')
        btn_exit.clicked.connect(lambda:self.ExitApp())
        btn = QtGui.QPushButton('Update parameters')
        btn.clicked.connect(lambda: self.updateFromWindow(integration, sun_area_edit, comboBox))
        #btn.clicked.connect(lambda: (self.SC.setParameters(float(integration.text()), sun_area_edit.text(), comboBox.currentIndex())))

        self.ui_label_cam_coord = QtGui.QLabel("x: UNLL <br> Y: NULL")

        mainLayout.addWidget(btn_exit)
        mainLayout.addWidget(self.ui_label_cam_coord)
        mainLayout.addWidget(QtGui.QLabel("Integration time"))
        mainLayout.addWidget(integration)
        mainLayout.addWidget(QtGui.QLabel("Observing name"))
        mainLayout.addWidget(sun_area_edit)
        mainLayout.addWidget(QtGui.QLabel("Data type"))
        mainLayout.addWidget(comboBox)
        mainLayout.addWidget(btn)
        mainLayout.addWidget(recording)
        mainLayout.addWidget(ploting)
        
        self.set_window.show()

    def updateFromWindow(self, integration, sun_area_edit, comboBox):
        self.SC.setParameters(float(integration.text()), sun_area_edit.text(), comboBox.currentIndex())

        rospy.set_param(self.node_name +"/spec_inegration", float(integration.text()))
        rospy.set_param(self.node_name +"/spec_data_type", int(comboBox.currentIndex()))
        #rospy.set_param(self.node_noma +"/spec_name", )
        rospy.set_param(self.node_name +"/spec_obsarea", str(sun_area_edit.text()) )


        #rosparam.dump_params(self.yaml_config_path, self.node_name)
        #print 
        with open(self.yaml_config_path, 'w') as f:
            yaml.dump(rospy.get_param(self.node_name), f, default_flow_style=False)



    def getCommand(self, command):
        print (command)
        if command.data == 'start':
            self.status = 10

        if command.data == 'pause':
            self.status = 1

        if command.data == 'recenter':
            self.target = self.center




if __name__ == '__main__':
    m = sunpos()

