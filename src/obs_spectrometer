#!/usr/bin/env python
# -*- coding: utf-8 -*-

import time
import datetime
import rospy
import rosparam
import std_msgs
import sensor_msgs
import geometry_msgs.msg
import numpy as np
import json
import yaml
import os, sys
import h5py
import pyqtgraph as pg
from PyQt4 import QtGui
from PyQt4 import QtCore
# from PyQt5 import QtGui
# from PyQt5 import QtCore
# from PyQt5 import QtWidgets
# from PyQt5.QtWidgets import QMainWindow, QApplication
# from PyQt5.QtWidgets import (QWidget, QPushButton,
#                              QHBoxLayout, QVBoxLayout, QApplication,
#                              QLineEdit, QLabel, QComboBox, QCheckBox)
from threading import Thread

import seabreeze
seabreeze.use("pyseabreeze")
import seabreeze.spectrometers as sb


from arom_helper import AromNode


class SpecCapture(Thread):
    def __init__(self, integr_time = 100, device = None, serial = 'serial', calib_coef = [1, 0, 0]):

        Thread.__init__(self)
        self.serial = serial 
        self.integr_time = integr_time
        self.alive = True
        self.recording = False
        self.image_types = ['LIGHT', 'LIGHT_TEST', 'DARK', 'BIAS', 'none']
        self.image_type = 0
        self.obs_area = 'sun_area'
        self.hdffile = None
        self.calib_coef = calib_coef

        self.pos_r, self.pos_alpha, self.clonka = 0,0,0
        self.camera_pos = [0, 0]
        self.camera_area= 0


        self.capture_start = None
        self.captured_count = 0
        self.caputer_limit = 0
        self.capture_period = 0
        self.lastcapture = 0
        self.lastparam = 0

        self.spectrometer = sb.Spectrometer(device)
        print(device)
        self.spectrometer.integration_time_micros(10000)
        self.vl_range =  self.spectrometer.wavelengths()
        self.position_error = [0, 0]
        self.correction = False


        #self.spectrometer = sb.Spectrometer.from_serial_number()
        self.NewFileToSave()
        self.setIntegration()
        #self.vl_range =  self.spectrometer.wavelengths()

        self.serial = self.spectrometer.serial_number
        print(self.spectrometer.serial_number)
        print(self.spectrometer.model)
        print(self.spectrometer.pixels)

    def getSN(self):
        return self.serial

    def getVaveLength(self):
        return self.vl_range
 
    def run(self):
        while self.alive:
            self.spec  = self.spectrometer.intensities(correct_dark_counts=self.correction, correct_nonlinearity=self.correction)
            #print self.spec
            #self.spec = np.random.random(self.vl_range.shape[0])*2**16
            #self.spec = self.spectrometer.intensities(correct_dark_counts=False, correct_nonlinearity=False)
            
            if self.recording:
                if (self.lastcapture + self.capture_period) < time.time():
                    self.AppendRow(self.spec)
                    self.lastcapture = time.time()
                else:
                    time.sleep(0.1/1000.0)
            else:
                time.sleep(0.5)

            if self.caputer_limit > 0 and self.recording:
                if self.caputer_limit <= self.captured_count:
                    self.recording= False
                    self.hdffile.flush()
                    print("Flush to file")

        self.spectrometer.close()

    def AppendRow(self, data, flush = False):
        #print("append")
        size = self.hdfset.shape
        self.hdfset.resize((size[0]+1, size[1]))
        self.hdfset[size[0],:] = data
        if size[0] % 50 ==0 or (self.lastparam + 5) > time.time():
            self.AppendParam()
        if (size[0] % 200 == 0) or flush:
            self.hdffile.flush()
            print("Flush to file")
        self.captured_count += 1

    def AppendParam(self, pos = None, clonka = None):
        if not pos and not clonka:
            size = self.hdfset_pram.shape
            self.hdfset_pram.resize((size[0]+1, size[1]))
            self.hdfset_pram[size[0],:] = [time.time() - self.capture_start, self.clonka, self.pos_alpha, self.pos_r, self.position_error[0], self.position_error[1], self.camera_pos[0], self.camera_pos[1], self.camera_area]
            self.lastparam = time.time()
            #self.hdfset_pram.flush()
        elif pos:
            self.pos_alpha, self.pos_r = pos
        elif clonka:
            self.clonka = clonka


    def getTitle(self):
        if self.capture_start and self.recording:
            lenght = int(time.time() - self.capture_start)/60.0
        else:
            lenght = 0
        return "File: <b>%s</b> \t Dataset:<b>%s</b><br> Integration_time: <b>%s</b>, \t Image_type: <b>%s</b>, \t Recording: <b>%s</b>, \t Time: <b>%.2f</b> min, \t Count: <b>%s</b>/%s" %(self.hdf_file, self.dataset_name, self.integr_time, self.image_types[self.image_type], self.recording, lenght, self.captured_count, self.caputer_limit)

    def getSpectrum(self):
        return self.spec

    def setParameters(self, integration, area, data_type):
        if area:
            if area != self.obs_area:
                print(area)
                self.obs_area = str(area)
                self.NewFileToSave()
        if integration:
            self.setIntegration(integration)
        if data_type:
            self.image_type = data_type


    def setIntegration(self, time = None):
        print("NewIntegrationTime", time)
        if time:
            self.integr_time = time
        self.spectrometer.integration_time_micros(int(self.integr_time*1000))
        self.setRecording(self.recording, limit = self.caputer_limit, period = self.capture_period, correction = self.correction)

    def setRecording(self, record = False, limit = 0, period = 0, correction = False):
        print("recording", record)
        self.recording = record
        self.caputer_limit = limit
        self.capture_period = period
        self.correction = correction
        if record:
            self.CreateDataset()
            self.hdfset.attrs.create('DATE_ROW0', str(datetime.datetime.utcnow()))
            self.capture_start = time.time()
            self.captured_count = 0
        else:
            self.capture_start = None
        self.hdffile.flush()
        print("Flush to file")


    def CreateDataset(self, dataset_name = None):
        self.hdffile.flush()
        if not dataset_name:
            dataset_name = "%04d_%04dms_%s" %(len(self.hdffile), self.integr_time, self.image_types[self.image_type])
        self.dataset_name = dataset_name
        print("NewDataset", dataset_name)
        self.hdfset = self.hdffile.create_dataset(dataset_name, maxshape = (None, self.vl_range.shape[0]), shape = (0, self.vl_range.shape[0]), dtype='f', chunks=True)
        self.hdfset.attrs.create('DATE_CREATE', str(datetime.datetime.utcnow()))
        self.hdfset.attrs.create('ROW_DELTA', self.integr_time)
        self.hdfset.attrs.create('COL_VAL0', self.vl_range[0])
        self.hdfset.attrs.create('COL_LIST', self.vl_range)
        self.hdfset.attrs.create('COL_CAL1', self.calib_coef[0])
        self.hdfset.attrs.create('COL_CAL2', self.calib_coef[1])
        self.hdfset.attrs.create('COL_CAL3', self.calib_coef[2])
        self.hdfset.attrs.create('DEVICE_name', str(self.spectrometer.model))
        self.hdfset.attrs.create('DEVICE_serial', str(self.spectrometer.serial_number))

        self.hdfset.attrs.create('OBS_area', str(self.obs_area))
        self.hdfset.attrs.create('OBS_type', str(self.image_types[self.image_type]))
        #self.hdfset.attrs.create('OBS_coordA', str("aaa"))
        #self.hdfset.attrs.create('OBS_coordB', str("bbb"))

        print(self.hdfset, self.hdfset.shape)

        self.hdfset_pram = self.hdffile.create_dataset(dataset_name+'param', maxshape = (None, 32), shape = (0, 9), dtype='f', chunks=True)
        self.hdfset_pram.attrs.create('DATE_CREATE', str(datetime.datetime.utcnow()))

        return self.hdfset

    def NewFileToSave(self, name = None):
        if self.hdffile:
            self.hdffile.close()
        if not name:
            name = os.path.join("/mnt/data/", datetime.datetime.utcnow().strftime("%Y-%m-%d"), self.obs_area) + "/" + self.obs_area + datetime.datetime.now().strftime("_%Y-%m-%d_" + self.spectrometer.serial_number + ".hdf")
        
        directory = os.path.dirname(name)
        if not os.path.exists(directory):
            os.makedirs(directory)      

            #name = os.path.join(os.path.expanduser("~"), "arom_ws", "data") + "/" + self.obs_area + datetime.datetime.now().strftime("_%Y-%m-%d_" + self.serial + ".hdf")
        self.hdf_file = name
        self.hdffile = h5py.File(self.hdf_file, "a")
        return self.CreateDataset()

    def setClonka(self, diameter = 0):
        self.clonka = diameter
        return self.clonka

    def setPositionError(self, position):
        self.position_error = [position.x, position.y]

    def setCameraPosition(self, position):
        self.camera_pos = [position.x, position.y]
        self.camera_area= position.z

    def exit(self):
        self.alive = False
        #self.spectrometer.close()

















######################################################################################################
######################################################################################################
######################################################################################################
######################################################################################################


class spectrometer(AromNode):
    node_name = "obs_spectrometer"
    node_type = "obs_spectrometer"
    node_pymlab = True

    def get_position(self, data):
        print(data.data)
        d = data.data.split(';')
        self.pos_alpha = float(d[0])
        self.pos_r = float(d[1])

    def get_position_error(self, data):
        print(data)
        self.position_error =data
        self.SC1.setPositionError(data)
        self.SC2.setPositionError(data)

    def get_camera_pos(self, data):
        print(data)
        self.SC1.setCameraPosition(data)
        self.SC2.setCameraPosition(data)

    def get_clonka(self, data):
        print("Zmenena poloha clonky", data.data)
        d = data.data.split(';')
        self.clonka = float(d[0])
        self.SC1.setClonka(self.clonka)
        self.SC2.setClonka(self.clonka)

    def __init__(self):
        # print os.path.dirname(os.path.realpath(__file__))
        # print os.getcwd()
        # print __file__
        # print __file__+'.feature.hbs'

        print("spousteni softwaru pro spektraky")


        AromNode.__init__(self)
        node_name = rospy.get_name()
        self.node_name = node_name
        print(node_name)

        self.LoadParamsFromConfig()
        

        self.integr1_time = rospy.get_param(self.node_name+"/spec1_inegration", 50)
        self.integr2_time = rospy.get_param(self.node_name+"/spec2_inegration", 50)
        self.recording = False
        self.recording1 = False
        self.recording2 = False
        self.plot = True
        self.lastplot = time.time()

        self.capture_period = 250
        self.capture_count = -1
        self.caputer_limit = 0
        self.capture_period = 0
        self.correction = False

        devices = sb.list_devices()
        print(devices)

        spec1_calib = [rospy.get_param(self.node_name+"/spec1_coef1", 0), rospy.get_param(self.node_name+"/spec1_coef2", 0), rospy.get_param(self.node_name+"/spec1_coef3", 0)] 
        spec2_calib = [rospy.get_param(self.node_name+"/spec2_coef1", 0), rospy.get_param(self.node_name+"/spec2_coef2", 0), rospy.get_param(self.node_name+"/spec2_coef3", 0)] 

        self.SC1 = SpecCapture(serial = node_name[1:], device= devices[0], calib_coef = spec1_calib)
        self.SC2 = SpecCapture(serial = node_name[1:], device= devices[1], calib_coef = spec2_calib)
        self.vl1_range = self.SC1.getVaveLength()
        self.vl2_range = self.SC2.getVaveLength()

        pw = pg.plot(title="Spetral %s data" %(self.SC1.getSN()))
        print(pw)
        pw2 = pg.plot(title="Spetral %s data" %(self.SC2.getSN()))
        print(pw)
        self.PrepareSettingsWindow()

        #self.SC.setHdfset(self.NewFileToSave())
        self.SC1.start()
        self.SC2.start()

        rospy.Subscriber("position", std_msgs.msg.String, self.get_position)
        rospy.Subscriber("pos_error", geometry_msgs.msg.Point, self.get_position_error)
        rospy.Subscriber("sun_pos", geometry_msgs.msg.Point, self.get_camera_pos)
        rospy.Subscriber("clonka", std_msgs.msg.String, self.get_clonka)

        #self.pub_iris_pos = rospy.Publisher(node_name+"/iris/position", std_msgs.msg.String, queue_size=1, latch = True)
        #self.sub_iris_request = rospy.Subscriber("/ui/keyboard/out", std_msgs.msg.String, self.ui_action)
        #self.set_feature('external',  {'feature': __file__+'.feature.hbs', 'id': 'motor_focus', 'name': 'Motor Ostreni', 'node_name': node_name, 'toppic': node_name+'/motor_focus', 'iris_range': self.conf['iris']['range'], 'focus_range': self.conf['focus']['range']})

        rate = rospy.Rate(50)
        while not rospy.is_shutdown():
            rate.sleep()
            try:
                spec1 = self.SC1.getSpectrum()
                self.qtwait()
                spec2 = self.SC2.getSpectrum()
                self.qtwait()
                if self.recording:
                    print("row")
                    self.AppendRow(spec)
                    self.captured_count += 1
                    # if int(self.value_count.text()) == 0:
                    #     self.setRecording(False)
                    #     self.updateRecording()
                    # if int(self.value_count.text()) > 0:
                    #     self.value_count.setText( str(int(self.value_count.text()) - 1) )

                pg.QtGui.QApplication.processEvents()
                if self.plot and time.time() > self.lastplot+0.25:
                    self.lastplot = time.time()
                    pw.plot(self.vl1_range, spec1, pen=(100, 20, 20), clear=True)
                    pw2.plot(self.vl2_range, spec2, pen=(100, 20, 20), clear=True)
                    self.qtwait()
                pw2.setTitle(self.SC2.getTitle())
                pw.setTitle(self.SC1.getTitle())
                self.qtwait()

            except Exception as e:
                print("err1>", repr(e))

        self.SC1.exit()
        self.SC2.exit()

        #self.hdfset[]

    def qtwait(self):
                pg.QtGui.QApplication.processEvents()
                pg.QtGui.QApplication.processEvents()
                pg.QtGui.QApplication.processEvents()

    def LoadParamsFromConfig(self):
        self.yaml_config_path = os.path.join(os.path.dirname(os.path.dirname(os.path.realpath(__file__))), 'config', self.node_name[1:]+".yaml")
        load_params = rosparam.load_file(self.yaml_config_path, self.node_name)
        for params, ns in load_params:
            rosparam.upload_params(ns,params)
        return load_params


    def ExitApp(self):
        print("Zacinam se ukoncovat")
        
        rospy.signal_shutdown("closed by window")

    def PrepareSettingsWindow(self):
        self.set_window = QtGui.QWidget()
        self.set_window.setWindowFlags(QtCore.Qt.WindowTitleHint)
        self.set_window.setWindowFlags(QtCore.Qt.WindowStaysOnTopHint)

        #self.set_window.resize(250, 150)
        #self.set_window.move(300, 300)
        self.set_window.setWindowTitle('Setting')
        mainLayout = QtGui.QVBoxLayout()
        self.set_window.setLayout(mainLayout)
        #self.set_window.closeEvent(self.ExitApp)

        integration1 = QtGui.QLineEdit(str(int(self.integr1_time)))
        integration1.setValidator(QtGui.QIntValidator())
        integration1.setMaxLength(4)

        integration2 = QtGui.QLineEdit(str(int(self.integr2_time)))
        integration2.setValidator(QtGui.QIntValidator())
        integration2.setMaxLength(4)

        self.value_period = QtGui.QLineEdit(str(int(self.capture_period)))
        self.value_period.setText(str(int(self.capture_period)))
        self.value_period.setValidator(QtGui.QIntValidator())
        self.value_period.setMaxLength(4)

        self.value_count = QtGui.QLineEdit(str(int(self.capture_count)))
        self.value_count.setValidator(QtGui.QIntValidator())
        self.value_count.setMaxLength(4)

        sun_area_edit = QtGui.QLineEdit("sun_area")


        label = QtGui.QLabel('Integration time')

        comboBox = QtGui.QComboBox()
        comboBox.addItem("LIGHT")
        comboBox.addItem("STRED_SLUNCE")
        comboBox.addItem("DARK")
        comboBox.addItem("BIAS")
        comboBox.addItem("none")
        comboBox.setCurrentIndex(rospy.get_param(self.node_name+"/spec_data_type",0))

        self.btn_recording = QtGui.QCheckBox()
        self.btn_recording.setText("recording")
        self.btn_recording.setCheckable(True)
        self.btn_recording.setChecked(self.recording)
        self.btn_recording.toggled.connect(self.updateRecording)

        ploting = QtGui.QCheckBox()
        ploting.setText("plotting")
        ploting.setCheckable(True)
        ploting.setChecked(self.plot)
        ploting.toggled.connect(lambda:self.setPlotting(ploting.isChecked()))

        self.btn_correct = QtGui.QCheckBox()
        self.btn_correct.setText("Korekce sepektroskopu")
        self.btn_correct.setCheckable(True)
        self.btn_correct.setChecked(self.correction)
        self.btn_correct.toggled.connect(lambda:self.setCorrection(self.btn_correct.isChecked()))


        btn_exit = QtGui.QPushButton('exit')
        btn_exit.clicked.connect(lambda:self.ExitApp())
        btn = QtGui.QPushButton('Update parameters')
        btn.clicked.connect(lambda: self.updateFromWindow(integration1, integration2, sun_area_edit, comboBox))
        #btn.clicked.connect(lambda: (self.SC.setParameters(float(integration.text()), sun_area_edit.text(), comboBox.currentIndex())))

        mainLayout.addWidget(btn_exit)
        mainLayout.addWidget(QtGui.QLabel("Integration %s [ms]" %(self.SC1.getSN())))
        mainLayout.addWidget(integration1)
        mainLayout.addWidget(QtGui.QLabel("Integration %s [ms]" %(self.SC2.getSN())))
        mainLayout.addWidget(integration2)
        mainLayout.addWidget(QtGui.QLabel("Capture period [ms]"))
        mainLayout.addWidget(self.value_period)
        mainLayout.addWidget(QtGui.QLabel("Count"))
        mainLayout.addWidget(self.value_count)
        mainLayout.addWidget(QtGui.QLabel("Observing name"))
        mainLayout.addWidget(sun_area_edit)
        mainLayout.addWidget(QtGui.QLabel("Data type"))
        mainLayout.addWidget(comboBox)
        mainLayout.addWidget(btn)
        mainLayout.addWidget(self.btn_recording)
        mainLayout.addWidget(ploting)
        mainLayout.addWidget(self.btn_correct)

        '''
        mainLayout.addWidget(btn_exit)
        mainLayout.addWidget(QtGui.QLabel("Integration time"))
        mainLayout.addWidget(integration)
        mainLayout.addWidget(QtGui.QLabel("Observing name"))
        mainLayout.addWidget(sun_area_edit)
        mainLayout.addWidget(QtGui.QLabel("Data type"))
        mainLayout.addWidget(comboBox)
        mainLayout.addWidget(btn)
        mainLayout.addWidget(recording)
        mainLayout.addWidget(ploting)
        '''
        self.set_window.show()

    def updateRecording(self):
        self.SC1.setRecording(self.btn_recording.isChecked(), limit = int(self.value_count.text()), period = int(self.value_period.text())/1000.0, correction = self.correction)
        self.SC2.setRecording(self.btn_recording.isChecked(), limit = int(self.value_count.text()), period = int(self.value_period.text())/1000.0, correction = self.correction)
        if self.btn_recording.isChecked():
            self.capture_start = time.time()
        else:
            self.capture_start = None

    def updateFromWindow(self, integration1, integration2, sun_area_edit, comboBox):
        self.SC1.setParameters(int(float(integration1.text())), sun_area_edit.text(), comboBox.currentIndex())
        self.SC2.setParameters(int(float(integration2.text())), sun_area_edit.text(), comboBox.currentIndex())

        rospy.set_param(self.node_name +"/spec1_inegration", float(integration1.text()))
        rospy.set_param(self.node_name +"/spec2_inegration", float(integration2.text()))
        rospy.set_param(self.node_name +"/spec_data_type", int(comboBox.currentIndex()))
        #rospy.set_param(self.node_noma +"/spec_name", )
        rospy.set_param(self.node_name +"/spec_obsarea", str(sun_area_edit.text()) )

        with open(self.yaml_config_path, 'w') as f:
            yaml.dump(rospy.get_param(self.node_name), f, default_flow_style=False)


    def setRecording(self, record = False):
        print("recording", record)
        self.recording = record

    def setCorrection(self, record = False):
        print("correction,", record)
        self.correction = record

    def setPlotting(self, plot = False):
        print("plotting", plot)
        self.plot = plot


if __name__ == '__main__':
    m = spectrometer()
