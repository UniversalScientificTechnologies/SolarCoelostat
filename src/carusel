#!/usr/bin/env python
# -*- coding: utf-8 -*-

import __init__
import os, sys
import math
import time, datetime
import rospy, rosparam
import std_msgs
import sensor_msgs
import geometry_msgs
import arom
from PyQt4 import QtGui
from PyQt4 import QtCore
import numpy as np
#from __init__ import AromNode
from arom_helper import AromNode
import yaml
from pymlab import config


class axis:
    def __init__(self, spi, SPI_CS, Direction, StepsPerUnit):
        ' One axis of robot '
        self.spi = spi
        self.CS = SPI_CS
        self.Dir = Direction
        self.SPU = StepsPerUnit
        self.Reset()

        #self.positions = [[0, '1, 4mm, 61"'],
        #                  [2, '3, 6mm, 200"'],
        #                  [4, '5, 10mm, 154"'],
        #                  [1, '2, 13mm, 200"'],
        #                  [3, '4, 15mm, 130"'],
        #                  [5, '6, 18mm, 276"'],
        #                  [6, '7, 20mm, 307"']]

    def Reset(self):
        ' Reset Axis and set default parameters for H-bridge '
        self.spi.SPI_write_byte(self.CS, 0xC0)      # reset
#        self.spi.SPI_write_byte(self.CS, 0x14)      # Stall Treshold setup
#        self.spi.SPI_write_byte(self.CS, 0xFF)  
#        self.spi.SPI_write_byte(self.CS, 0x13)      # Over Current Treshold setup 
#        self.spi.SPI_write_byte(self.CS, 0xFF)  
        self.spi.SPI_write_byte(self.CS, 0x15)      # Full Step speed 
        self.spi.SPI_write_byte(self.CS, 0xFF)
        self.spi.SPI_write_byte(self.CS, 0xFF) 
        self.spi.SPI_write_byte(self.CS, 0x05)      # ACC 
        self.spi.SPI_write_byte(self.CS, 0x00)
        self.spi.SPI_write_byte(self.CS, 0x30) 
        self.spi.SPI_write_byte(self.CS, 0x06)      # DEC 
        self.spi.SPI_write_byte(self.CS, 0x00)
        self.spi.SPI_write_byte(self.CS, 0x30) 
        self.spi.SPI_write_byte(self.CS, 0x0A)      # KVAL_RUN
        self.spi.SPI_write_byte(self.CS, 0xf0)
        self.spi.SPI_write_byte(self.CS, 0x0B)      # KVAL_ACC
        self.spi.SPI_write_byte(self.CS, 0xf0)
        self.spi.SPI_write_byte(self.CS, 0x0C)      # KVAL_DEC
        self.spi.SPI_write_byte(self.CS, 0xf0)
        self.spi.SPI_write_byte(self.CS, 0x18)      # CONFIG
        self.spi.SPI_write_byte(self.CS, 0b00111000)
        self.spi.SPI_write_byte(self.CS, 0b00000000)
      
    def MaxSpeed(self, speed):
        ' Setup of maximum speed '
        self.spi.SPI_write_byte(self.CS, 0x07)       # Max Speed setup 
        self.spi.SPI_write_byte(self.CS, 0x00)
        self.spi.SPI_write_byte(self.CS, speed)  

    def ReleaseSW(self):
        ' Go away from Limit Switch '
        while self.ReadStatusBit(2) == 1:           # is Limit Switch ON ?
            self.spi.SPI_write_byte(self.CS, 0x92 | (~self.Dir & 1))     # release SW 
            while self.IsBusy():
                pass
            self.MoveWait(10)           # move 10 units away
 
    def GoZero(self, speed):
        ' Go to Zero position '
        self.ReleaseSW()

        self.spi.SPI_write_byte(self.CS, 0x82 | (self.Dir & 1))       # Go to Zero
        self.spi.SPI_write_byte(self.CS, 0x00)
        self.spi.SPI_write_byte(self.CS, speed)  
        while self.IsBusy():
            pass
        time.sleep(0.3)
        self.ReleaseSW()

    def Move(self, units):
        ' Move some distance units from current position '
        steps = units * self.SPU  # translate units to steps 
        if steps > 0:                                          # look for direction
            self.spi.SPI_write_byte(self.CS, 0x40 | (~self.Dir & 1))       
        else:
            self.spi.SPI_write_byte(self.CS, 0x40 | (self.Dir & 1)) 
        steps = int(abs(steps))     
        self.spi.SPI_write_byte(self.CS, (steps >> 16) & 0xFF)
        self.spi.SPI_write_byte(self.CS, (steps >> 8) & 0xFF)
        self.spi.SPI_write_byte(self.CS, steps & 0xFF)

    def MoveWait(self, units):
        ' Move some distance units from current position and wait for execution '
        self.Move(units)
        while self.IsBusy():
            pass

    def Float(self):
        ' switch H-bridge to High impedance state '
        self.spi.SPI_write_byte(self.CS, 0xA0)

    def ReadStatusBit(self, bit):
        ' Report given status bit '
        self.spi.SPI_write_byte(self.CS, 0x39)   # Read from address 0x19 (STATUS)
        self.spi.SPI_write_byte(self.CS, 0x00)
        data0 = self.spi.SPI_read_byte()           # 1st byte
        self.spi.SPI_write_byte(self.CS, 0x00)
        data1 = self.spi.SPI_read_byte()           # 2nd byte
        #print hex(data0), hex(data1)
        if bit > 7:                                   # extract requested bit
            OutputBit = (data0 >> (bit - 8)) & 1
        else:
            OutputBit = (data1 >> bit) & 1        
        return OutputBit

    
    def IsBusy(self):
        """ Return True if tehre are motion """
        if self.ReadStatusBit(1) == 1:
            return False
        else:
            return True

# End Class axis --------------------------------------------------





class carusel(AromNode):
    node_name = "carusel"
    node_type = "carusel"

    def __init__(self):
        self.position = 0

        #self.set_feature('hsfa_sunpos', {'port': port})
        #self.image_pub = rospy.Publisher("image_topic", sensor_msgs.msg.Image, queue_size=1)
        #self.image_pub2 = rospy.Publisher("image_topic2", sensor_msgs.msg.Image, queue_size=1)
        #self.pub_error = rospy.Publisher("sun_err", geometry_msgs.msg.Point, queue_size=1)
        #self.pub_pos = rospy.Publisher("sun_pos", geometry_msgs.msg.Point, queue_size=1)
        #rospy.Subscriber("image_target", geometry_msgs.msg.Point, self.newTarget)
        #rospy.Subscriber("image_command", std_msgs.msg.String, self.getCommand)

        self.LoadParamsFromConfig()
        
        self.positions = [[0, '1, 4mm, 61"', 4],
                  [2, '3, 6mm, 92"', 6],
                  [4, '5, 10mm, 154"', 10],
                  [1, '2, 13mm, 200"', 13],
                  [3, '4, 15mm, 230"', 15],
                  [5, '6, 18mm, 276"', 18],
                  [6, '7, 20mm, 307"', 20]]

        app = QtGui.QApplication(sys.argv)
        self.prepareSettingsWindow()
        QtGui.QApplication.processEvents()
    
    

        cfg = config.Config(
            i2c = {
                "port": 1,
            },

            bus = [
                { 
                "name":"spi", 
                "type":"i2cspi",
                "address": 0x2e,
                },
            ],
        )
        cfg.initialize()

        spi = cfg.get_device("spi")
        spi.route()

        AromNode.__init__(self)
        self.iris_pos = rospy.Publisher("/clonka", std_msgs.msg.String, latch = True)


        spi.SPI_config(spi.I2CSPI_MSB_FIRST| spi.I2CSPI_MODE_CLK_IDLE_HIGH_DATA_EDGE_TRAILING| spi.I2CSPI_CLK_461kHz)

        print "Axis inicialization"
        self.X = axis(spi, spi.I2CSPI_SS1, 0, 641)    # set Number of Steps per axis Unit and set Direction of Rotation
        self.X.Reset()
        self.X.MaxSpeed(5)                      # set maximal motor speed 

        i = 0

        self.btn.setStyleSheet("background-color: orange")
        self.X.MoveWait(100)
        while True:
            QtGui.QApplication.processEvents()
            timestart = time.time()
            self.X.MoveWait(100)
            duration = time.time() - timestart
            print "duration: ", duration, "s"
            if duration < 1:
                break

        self.btn.setStyleSheet("")
        print "NALEZENY KONCOVY BOD"
        self.currentPositionLabel.setText("Poloha karuselu je %s." %(self.position+1))

        
        while not rospy.is_shutdown():
            try:
                QtGui.QApplication.processEvents()
                time.sleep(0.1)

            except Exception as e:
                print(e)


    def LoadParamsFromConfig(self):
        self.yaml_config_path = os.path.join(os.path.dirname(os.path.dirname(os.path.realpath(__file__))), 'config', self.node_name[1:]+".yaml")
        load_params = rosparam.load_file(self.yaml_config_path, self.node_name)
        for params, ns in load_params:
            rosparam.upload_params(ns,params)
        return load_params

    def moveTo(self):
        
        self.btn.setStyleSheet("background-color: orange")
        index = self.targetPosition.currentIndex()
        target = self.positions[index][0]
        self.iris_pos.publish("{};".format(0))
        print("Presun na pozici {};".format(target))

        while self.position != target:
            self.X.MoveWait(100)
            self.position += 1
            if self.position >= 8:
                self.position = 0
            print "pozice je:", self.position
            self.currentPositionLabel.setText("Poloha karuselu je %s." %(self.position+1))
            QtGui.QApplication.processEvents()
            QtGui.QApplication.processEvents()
        self.btn.setStyleSheet('')
        self.iris_pos.publish("{};".format(self.positions[self.position][2]))




    def ExitApp(self):
        rospy.signal_shutdown("closed by window")

    def prepareSettingsWindow(self):
        pass

        self.set_window = QtGui.QWidget()
        self.set_window.resize(250, 150)
        self.set_window.move(300, 300)
        self.set_window.setWindowTitle('Carusel ctrl')
        #self.set_window.show()

        self.set_window.setWindowFlags(QtCore.Qt.WindowTitleHint)
        self.set_window.setWindowFlags(QtCore.Qt.WindowStaysOnTopHint)

        
        mainLayout = QtGui.QVBoxLayout()
        self.set_window.setLayout(mainLayout)

        self.targetPosition = QtGui.QComboBox()
        for pos in self.positions:
            self.targetPosition.addItem(pos[1])
        #self.targetPosition.addItem("1")
        #self.targetPosition.addItem("2")
        #self.targetPosition.addItem("3")
        #self.targetPosition.addItem("4")
        #self.targetPosition.addItem("5")
        #self.targetPosition.addItem("6")
        #self.targetPosition.addItem("7")
        self.targetPosition.setCurrentIndex(0)

        self.currentPositionLabel = QtGui.QLabel("Calibration... please wait")

        btn_exit = QtGui.QPushButton('exit')
        btn_exit.clicked.connect(lambda:self.ExitApp())

        self.btn = QtGui.QPushButton('Rotate')
        self.btn.clicked.connect(self.moveTo)


        mainLayout.addWidget(btn_exit)
        mainLayout.addWidget(self.targetPosition)
        mainLayout.addWidget(self.currentPositionLabel)
        mainLayout.addWidget(self.btn)
        
        self.set_window.show()



if __name__ == '__main__':
    m = carusel()



