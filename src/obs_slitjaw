#!/usr/bin/env python
# -*- coding: utf-8 -*-

import time
import datetime
import rospy
import rosparam
import std_msgs
import numpy as np
import json
import yaml
import os, sys
import h5py
import pyqtgraph as pg
from PyQt4 import QtGui
from PyQt4 import QtCore
from threading import Thread
import zwoasi as asi
import cv2



from arom_helper import AromNode


class SpecCapture(Thread):
    def __init__(self, integr_time = 100, device = None, serial = 'serial'):

        Thread.__init__(self)
        self.serial = serial
        self.integr_time = integr_time
        self.alive = True
        self.recording = True
        self.image_types = ['LIGHT', 'LIGHT_TEST', 'DARK', 'BIAS', 'none']
        self.image_type = 0
        self.obs_area = 'sun_area'
        self.hdffile = None

        asi.init('/home/roman/ASI_linux_mac_SDK/lib/x64/libASICamera2.so')
        self.camera = asi.Camera(0)
        camera_info = self.camera.get_camera_property()

        # Get all of the camera controls
        print('')
        print('Camera controls:')
        self.camera.disable_dark_subtract()

        self.camera.set_image_type(asi.ASI_IMG_RAW16)
        self.camera.set_control_value(asi.ASI_GAIN, 200)
        self.camera.set_control_value(asi.ASI_EXPOSURE, 30000)
        #self.camera.set_control_value(asi.ASI_WB_B, 99)
        #self.camera.set_control_value(asi.ASI_WB_R, 75)
        #self.camera.set_control_value(asi.ASI_GAMMA, 50)
        self.camera.set_control_value(asi.ASI_BRIGHTNESS, 50)
        self.camera.set_control_value(asi.ASI_FLIP, 0)

        controls = self.camera.get_controls()

        print controls
        for cn in sorted(controls.keys()):
            print('    %s:' % cn)
            for k in sorted(controls[cn].keys()):
                print('        %s: %s' % (k, repr(controls[cn][k])))


        #self.spectrometer = sb.Spectrometer.from_serial_number()
        #self.NewFileToSave()
        #self.setIntegration()
        #self.vl_range =  self.spectrometer.wavelengths()

    def getfilename(self):
        return  os.path.join("/mnt/data/", datetime.datetime.utcnow().strftime("%y-%m-%d"), self.obs_area, "SlitJaw") + "/" + self.obs_area + datetime.datetime.utcnow().strftime("_%Y-%m-%d_%h%m%s" + ".tif")



    def run(self):
        cv2.namedWindow('SlitJaw', cv2.WINDOW_NORMAL)
        self.NewFileToSave()
        while self.alive:
            if self.recording:
                print "ahoj"
                filename = self.getfilename()
                print filename
                img = self.camera.capture(filename=filename)
                #gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
                cv2.imshow("SlitJaw", img)
            else:
                time.sleep(0.5)
        self.camera.close()

    #def AppendRow(self, data):
        #size = self.hdfset.shape
        #self.hdfset.resize((size[0]+1, size[1]))
        #self.hdfset[size[0],:] = data
        #if size[0] % 200 == 0:
        #    self.hdffile.flush()
        #    print "Flush to file"

    def getTitle(self):
        return "File: <b>%s</b> \t Dataset:<b>%s</b><br> Integration_time: <b>%s</b> \t Image_type: <b>%s</b> \t Recording: <b>%s</b>" %(self.hdf_file, self.dataset_name, self.integr_time, self.image_types[self.image_type], self.recording)


    def setParameters(self, integration, area, data_type):
        if area:
            if area != self.obs_area:
                print area
                self.obs_area = str(area)
                self.NewFileToSave()
        if integration:
            self.setIntegration(integration)
        if data_type:
            self.image_type = data_type


    def setIntegration(self, time = None):
        print "NewIntegrationTime", time
        if time:
            self.integr_time = time

        print "integration is", int(self.integr_time)
        self.camera.set_control_value(asi.ASI_EXPOSURE, int(self.integr_time*1000))
        #self.camera.set_control_value(asi.ASI_EXPOSURE, self.integr_time)
        self.setRecording(self.recording)

    def setRecording(self, record = False):
        print "recording", record
        self.recording = record
        if record:
            pass
            #self.CreateDataset()
            #self.hdfset.attrs.create('DATE_ROW0', str(datetime.datetime.utcnow()))

    def CreateDataset(self, dataset_name = None):
        pass

        # self.hdffile.flush()
        # if not dataset_name:
        #     dataset_name = "%04d_%04dms_%s" %(len(self.hdffile), self.integr_time, self.image_types[self.image_type])
        # self.dataset_name = dataset_name
        # print "NewDataset", dataset_name
        # self.hdfset = self.hdffile.create_dataset(dataset_name, maxshape = (None, self.vl_range.shape[0]), shape = (0, self.vl_range.shape[0]), dtype='f', chunks=True)
        # self.hdfset.attrs.create('DATE_CREATE', str(datetime.datetime.utcnow()))
        # self.hdfset.attrs.create('ROW_DELTA', self.integr_time)
        # self.hdfset.attrs.create('COL_VAL0', self.vl_range[0])
        # self.hdfset.attrs.create('COL_DELTA', self.vl_range[1]-self.vl_range[0])
        # #self.hdfset.attrs.create('DEVICE_name', str(self.spectrometer.model))
        # #self.hdfset.attrs.create('DEVICE_serial', str(self.spectrometer.serial_number))
        # self.hdfset.attrs.create('DEVICE_name', str(self.spectrometer.model))
        # self.hdfset.attrs.create('DEVICE_serial', str(self.spectrometer.serial_number))
        #
        # self.hdfset.attrs.create('OBS_area', str(self.obs_area))
        # self.hdfset.attrs.create('OBS_type', str(self.image_types[self.image_type]))
        # self.hdfset.attrs.create('OBS_coordA', str("aaa"))
        # self.hdfset.attrs.create('OBS_coordB', str("bbb"))
        #
        # print self.hdfset, self.hdfset.shape

        #return self.hdfset

    def NewFileToSave(self, name = None):
        if self.hdffile:
            self.hdffile.close()
        if not name:
            directory = os.path.join("/mnt/data/", datetime.datetime.utcnow().strftime("%y-%m-%d"), self.obs_area, "SlitJaw")
            if not os.path.exists(directory):
                os.makedirs(directory)
            name = directory + "/" + self.obs_area + datetime.datetime.now().strftime("_%Y-%m-%d_" + ".hdf")

        directory = os.path.dirname(name)
        if not os.path.exists(directory):
            os.makedirs(directory)

            #name = os.path.join(os.path.expanduser("~"), "arom_ws", "data") + "/" + self.obs_area + datetime.datetime.now().strftime("_%Y-%m-%d_" + self.serial + ".hdf")
        self.hdf_file = name
        #self.hdffile = h5py.File(self.hdf_file, "a")
        return self.CreateDataset()


    def exit(self):
        self.alive = False
        #self.spectrometer.close()


class spectrometer(AromNode):
    node_name = "obs_slitjaw"
    node_type = "obs_slitjaw"
    node_pymlab = True

    def __init__(self):
        print os.path.dirname(os.path.realpath(__file__))
        print os.getcwd()
        print __file__
        print __file__+'.feature.hbs'


        AromNode.__init__(self)
        node_name = rospy.get_name()
        self.node_name = node_name
        print node_name

        self.LoadParamsFromConfig()
        self.integr_time = 100
        self.recording = False

        app = QtGui.QApplication(sys.argv)
        self.prepareSettingsWindow()


        self.integr_time = rospy.get_param(self.node_name+"/cam_inegration", 50)
        self.recording = True
        self.plot = True
        self.SC = SpecCapture(serial = "", device= "")

        self.SC.start()

        #self.pub_iris_pos = rospy.Publisher(node_name+"/iris/position", std_msgs.msg.String, queue_size=1, latch = True)
        #self.sub_iris_request = rospy.Subscriber("/ui/keyboard/out", std_msgs.msg.String, self.ui_action)
        #self.set_feature('external',  {'feature': __file__+'.feature.hbs', 'id': 'motor_focus', 'name': 'Motor Ostreni', 'node_name': node_name, 'toppic': node_name+'/motor_focus', 'iris_range': self.conf['iris']['range'], 'focus_range': self.conf['focus']['range']})

        rate = rospy.Rate(50)
        while not rospy.is_shutdown():
            rate.sleep()
            try:
                QtGui.QApplication.processEvents()
                if self.recording:
                    pass
                    #print "row"
                #if self.plot and time.time() > self.lastplot+0.25:
                #    self.lastplot = time.time()


            except Exception, e:
                print "err1>", repr(e)

        self.SC.exit()

        #self.hdfset[]

    def LoadParamsFromConfig(self):
        self.yaml_config_path = os.path.join(os.path.dirname(os.path.dirname(os.path.realpath(__file__))), 'config', self.node_name[1:]+".yaml")
        load_params = rosparam.load_file(self.yaml_config_path, self.node_name)
        for params, ns in load_params:
            rosparam.upload_params(ns,params)
        return load_params


    def ExitApp(self):
        print "Zacinam se ukoncovat"

        rospy.signal_shutdown("closed by window")

    def prepareSettingsWindow(self):
        self.set_window = QtGui.QWidget()
        #self.set_window.resize(250, 150)
        self.set_window.move(800, 300)
        self.set_window.setWindowTitle('SlitJaw')

        self.set_window.setWindowFlags(QtCore.Qt.WindowTitleHint)
        self.set_window.setWindowFlags(QtCore.Qt.WindowStaysOnTopHint)

        #self.set_window.resize(250, 150)
        #self.set_window.move(300, 300)
        mainLayout = QtGui.QVBoxLayout()
        self.set_window.setLayout(mainLayout)
        #self.set_window.closeEvent(self.ExitApp)

        integration = QtGui.QLineEdit(str(self.integr_time))
        integration.setValidator(QtGui.QIntValidator())
        integration.setMaxLength(4)


        sun_area_edit = QtGui.QLineEdit("sun_area")


        label = QtGui.QLabel('Integration time')

        comboBox = QtGui.QComboBox()
        comboBox.addItem("LIGHT")
        comboBox.addItem("LIGHT_TEST")
        comboBox.addItem("DARK")
        comboBox.addItem("BIAS")
        comboBox.addItem("none")
        comboBox.setCurrentIndex(rospy.get_param(self.node_name+"/spec_data_type",0))

        self.btn_recording = QtGui.QCheckBox()
        self.btn_recording.setText("recording")
        self.btn_recording.setCheckable(True)
        self.btn_recording.setChecked(self.recording)
        self.btn_recording.toggled.connect(self.updateRecording)

        btn_exit = QtGui.QPushButton('exit')
        btn_exit.clicked.connect(lambda:self.ExitApp())
        btn = QtGui.QPushButton('Update parameters')
        btn.clicked.connect(lambda: self.updateFromWindow(integration, sun_area_edit, comboBox))
        #btn.clicked.connect(lambda: (self.SC.setParameters(float(integration.text()), sun_area_edit.text(), comboBox.currentIndex())))

        mainLayout.addWidget(btn_exit)
        mainLayout.addWidget(QtGui.QLabel("Integration time"))
        mainLayout.addWidget(integration)
        mainLayout.addWidget(QtGui.QLabel("Observing name"))
        mainLayout.addWidget(sun_area_edit)
        mainLayout.addWidget(QtGui.QLabel("Data type"))
        mainLayout.addWidget(comboBox)
        mainLayout.addWidget(btn)
        mainLayout.addWidget(self.btn_recording)
        #mainLayout.addWidget(ploting)

        self.set_window.show()
        print "$$$$$$$$$$$$$$$$ konec"

    def updateRecording(self):
        self.SC.setRecording(self.btn_recording.isChecked())

    def updateFromWindow(self, integration, sun_area_edit, comboBox):
        self.SC.setParameters(float(integration.text()), sun_area_edit.text(), comboBox.currentIndex())

        rospy.set_param(self.node_name +"/cam_inegration", float(integration.text()))
        rospy.set_param(self.node_name +"/cam_data_type", int(comboBox.currentIndex()))
        #rospy.set_param(self.node_noma +"/cam_name", )
        rospy.set_param(self.node_name +"/cam_obsarea", str(sun_area_edit.text()) )


        #rosparam.dump_params(self.yaml_config_path, self.node_name)
        #print
        with open(self.yaml_config_path, 'w') as f:
            yaml.dump(rospy.get_param(self.node_name), f, default_flow_style=False)


    def setRecording(self, record = False):
        print "recording", record
        self.recording = record

    def setPlotting(self, plot = False):
        print "plotting", plot
        self.plot = plot


if __name__ == '__main__':
    m = spectrometer()
