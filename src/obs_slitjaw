#!/usr/bin/env python
# -*- coding: utf-8 -*-

import time
import datetime
from astropy.time import Time
import rospy
import rosparam
import std_msgs
import numpy as np
import json
import yaml
import os, sys
#import h5py
import pyqtgraph as pg
from PyQt4 import QtGui
from PyQt4 import QtCore
from threading import Thread
import zwoasi as asi
import cv2
import matplotlib.pyplot as plt
from queue import Queue
from astropy.io import fits


from arom_helper import AromNode

def convert_nparray_to_QPixmap(img):
    w,h = img.shape
    # Convert resulting image to pixmap
    if img.ndim == 1:
        img =  cv2.cvtColor(img,cv2.COLOR_GRAY2RGB)

    qimg = QtGui.QImage(img.data, h, w, 3*h, QtGui.QImage.Format_RGB888) 
    qpixmap = QtGui.QPixmap(qimg)

    return qpixmap

class SpecCapture(Thread):
    def __init__(self, integr_time = 100, device = None, serial = 'serial', queue = None):

        Thread.__init__(self)
        self.serial = serial
        self.integr_time = integr_time
        self.alive = True
        self.recording = False
        self.image_types = ['LIGHT', 'LIGHT_TEST', 'DARK', 'BIAS', 'none']
        self.image_type = 0
        self.obs_area = 'sun_area'
        self.hdffile = None
        self.period = 5
        self.last_save = time.time()
        self.queue = queue

        asi.init('/home/roman/ASI_linux_mac_SDK/lib/x64/libASICamera2.so')
        self.camera = asi.Camera(0)
        camera_info = self.camera.get_camera_property()

        # Get all of the camera controls
        print('')
        print('Camera controls:')

        self.camera.set_control_value(asi.ASI_BANDWIDTHOVERLOAD, self.camera.get_controls()['BandWidth']['MinValue'])
        #self.camera.disable_dark_subtract()

        self.camera.set_image_type(asi.ASI_IMG_Y8)
        self.camera.set_control_value(asi.ASI_GAIN, 200)
        self.camera.set_control_value(asi.ASI_EXPOSURE, 50000)
        #self.camera.set_control_value(asi.ASI_WB_B, 99)
        #self.camera.set_control_value(asi.ASI_WB_R, 75)
        #self.camera.set_control_value(asi.ASI_GAMMA, 50)
        self.camera.set_control_value(asi.ASI_BRIGHTNESS, 50)
        self.camera.set_control_value(asi.ASI_FLIP, 0)
        self.camera.set_control_value(asi.ASI_HIGH_SPEED_MODE, 1)

        controls = self.camera.get_controls()

        #self.camera.stop_video_capture()
        #self.camera.stop_exposure()
        #self.camera.start_video_capture()

        print(controls)
        for cn in sorted(controls.keys()):
            print('    %s:' % cn)
            for k in sorted(controls[cn].keys()):
                print('        %s: %s' % (k, repr(controls[cn][k])))


    def getfilename(self):
        directory = os.path.join("/mnt/data/", datetime.datetime.utcnow().strftime("%Y-%m-%d"), self.obs_area, "SlitJaw") + "/"
        #directory = os.path.join("/mnt/data/", datetime.datetime.utcnow().strftime("%y-%m-%d"), "area", "Pointing")
        if not os.path.exists(directory):
            os.makedirs(directory)
        return directory + self.obs_area + datetime.datetime.utcnow().strftime("_%Y%m%d_%H%M%S_%f" + ".fits")

    def write_fits(self, img):

        nt = Time.now()

	hdr = fits.Header()
        hdr['OBSERVATORY'] = "Ondrejov"
        hdr['SOFTWARE'] = "OBS_SLITJAW, ust.cz"
        hdr['BITPIX'] = 16
        hdr['NAXIS'] = 2
        hdr['NAXIS1'] = img.shape[0]
        hdr['NAXIS2'] = img.shape[1]
        hdr['DATE'] = nt.fits
        hdr['DATE-OBS'] = nt.fits
        hdr['ORIGIN'] = ''
        hdr['OBJECT'] = "sun"
        hdr['BSCALE'] = 1
        hdr['BZERO'] = 2**15
        hdr['TELESCOPE'] = "Fikus"
        hdr['INSTRUMENT'] = "Fikus"

        hdu = fits.PrimaryHDU(img, header=hdr)
        hdul = fits.HDUList([hdu])
        hdul.writeto(self.getfilename())

    def run(self):
        print("Start of thread")
        self.NewFileToSave()  #vytvori novou slozku
        self.camera.set_image_type(asi.ASI_IMG_RAW16)

        print("start ...")
        while self.alive:
            if self.recording and (self.last_save + self.period/1000) < time.time():
                print("Save image")
                self.last_save = time.time()
                img = self.camera.capture()
                self.write_fits(img)
            else:
                img = self.camera.capture()
            self.queue.put(img/257)

        self.camera.close()

    def getTitle(self):
        return "File: <b>%s</b> \t Dataset:<b>%s</b><br> Integration_time: <b>%s</b> \t Image_type: <b>%s</b> \t Recording: <b>%s</b>" %(self.hdf_file, self.dataset_name, self.integr_time, self.image_types[self.image_type], self.recording)

    def set_gain(self, value):
        if value < 0: value = 0
        if value > 400: value = 400
        self.camera.set_control_value(asi.ASI_GAIN, value*1000)

    def set_integration(self, value):
        # value in ms
        if value < 0: value = 0
        if value > 10000: value = 10000
        self.camera.set_control_value(asi.ASI_EXPOSURE, value*1000)


    def setParameters(self, integration, area, data_type, period):
        if area:
            if area != self.obs_area:
                print area
                self.obs_area = str(area)
                self.NewFileToSave()
        if integration:
            self.setIntegration(integration)
        if data_type:
            self.image_type = data_type
        if period:
            self.period = period


    def setIntegration(self, time = None):
        print "NewIntegrationTime", time
        if time:
            self.integr_time = time

        print "integration is", int(self.integr_time)
        self.camera.set_control_value(asi.ASI_EXPOSURE, int(self.integr_time)*1000)
        #self.camera.set_control_value(asi.ASI_EXPOSURE, self.integr_time)
        self.setRecording(self.recording)

    def setRecording(self, record = False):
        print "recording", record
        self.recording = record
        if record:
            pass


    def NewFileToSave(self, name = None):
        #if self.hdffile:
        #    self.hdffile.close()
        #if not name:
        directory = os.path.join("/mnt/data/", datetime.datetime.utcnow().strftime("%Y-%m-%d"), self.obs_area, "SlitJaw")
        if not os.path.exists(directory):
            os.makedirs(directory)

    def exit(self):
        self.alive = False
        #self.spectrometer.close()


class slitjaw_cam(AromNode):
    node_name = "obs_slitjaw"
    node_type = "obs_slitjaw"
    node_pymlab = True

    def __init__(self):
        print os.path.dirname(os.path.realpath(__file__))
        print os.getcwd()
        print __file__
        #print __file__+'.feature.hbs'


        AromNode.__init__(self)
        node_name = rospy.get_name()
        self.node_name = node_name
        print node_name

        self.LoadParamsFromConfig()
        self.integr_time = 50
        self.period_time = 5
        self.gain = 200
        self.recording = False

        app = QtGui.QApplication(sys.argv)
        self.prepareSettingsWindow()
        self.prepareViewWindow()

        self.cam_img = None
        self.queue = Queue()
        self.integr_time = rospy.get_param(self.node_name+"/cam_inegration", 50)
        self.plot = True
        self.SC = SpecCapture(serial = "", device= "", queue = self.queue)

        self.SC.start()

        #self.pub_iris_pos = rospy.Publisher(node_name+"/iris/position", std_msgs.msg.String, queue_size=1, latch = True)
        #self.sub_iris_request = rospy.Subscriber("/ui/keyboard/out", std_msgs.msg.String, self.ui_action)
        #self.set_feature('external',  {'feature': __file__+'.feature.hbs', 'id': 'motor_focus', 'name': 'Motor Ostreni', 'node_name': node_name, 'toppic': node_name+'/motor_focus', 'iris_range': self.conf['iris']['range'], 'focus_range': self.conf['focus']['range']})

        rate = rospy.Rate(30)
        while not rospy.is_shutdown():
            rate.sleep()
            try:
                QtGui.QApplication.processEvents()
                if self.recording:
                    pass
                    #print "row"
                #if self.plot and time.time() > self.lastplot+0.25:
                #    self.lastplot = time.time()


                if not self.queue.empty():
                    img = self.queue.get()
                    w,h = img.shape
                    
                    # Convert resulting image to pixmap
                    img =  cv2.cvtColor(img, cv2.COLOR_GRAY2RGB)

                    qimg = QtGui.QImage(img.data, h, w, 3*h, QtGui.QImage.Format_RGB888) 
                    qpixmap = QtGui.QPixmap(qimg)
                    qpixmap = qpixmap.scaled(1000, 1000, QtCore.Qt.KeepAspectRatio)
                    self.canvas.setPixmap(qpixmap)
                    self.queue.queue.clear()


            except Exception, e:
                print "err1>", repr(e)

        self.SC.exit()

        #self.hdfset[]

    def LoadParamsFromConfig(self):
        self.yaml_config_path = os.path.join(os.path.dirname(os.path.dirname(os.path.realpath(__file__))), 'config', self.node_name[1:]+".yaml")
        load_params = rosparam.load_file(self.yaml_config_path, self.node_name)
        for params, ns in load_params:
            rosparam.upload_params(ns,params)
        return load_params


    def ExitApp(self):
        print "Zacinam se ukoncovat"

        rospy.signal_shutdown("closed by window")

    def prepareSettingsWindow(self):
        self.set_window = QtGui.QWidget()
        #self.set_window.resize(250, 150)
        self.set_window.move(800, 300)
        self.set_window.setWindowTitle('SlitJaw')

        self.set_window.setWindowFlags(QtCore.Qt.WindowTitleHint)
        self.set_window.setWindowFlags(QtCore.Qt.WindowStaysOnTopHint)

        #self.set_window.resize(250, 150)
        #self.set_window.move(300, 300)
        mainLayout = QtGui.QVBoxLayout()
        self.set_window.setLayout(mainLayout)
        #self.set_window.closeEvent(self.ExitApp)

        integration = QtGui.QLineEdit(str(self.integr_time))
        integration.setValidator(QtGui.QIntValidator())
        integration.textChanged.connect(lambda: self.SC.set_integration(int(integration.text())))
        integration.setMaxLength(5)

        gain = QtGui.QLineEdit(str(self.gain))
        gain.setValidator(QtGui.QIntValidator())
        gain.textChanged.connect(lambda: self.SC.set_gain(int(gain.text())))
        gain.setMaxLength(4)


        period = QtGui.QLineEdit(str(self.period_time))
        period.setValidator(QtGui.QIntValidator())
        period.setMaxLength(5)


        sun_area_edit = QtGui.QLineEdit("sun_area")

        comboBox = QtGui.QComboBox()
        comboBox.addItem("LIGHT")
        comboBox.addItem("LIGHT_TEST")
        comboBox.addItem("DARK")
        comboBox.addItem("BIAS")
        comboBox.addItem("none")
        comboBox.setCurrentIndex(rospy.get_param(self.node_name+"/spec_data_type",0))

        self.btn_recording = QtGui.QCheckBox()
        self.btn_recording.setText("recording")
        self.btn_recording.setCheckable(True)
        self.btn_recording.setChecked(self.recording)
        self.btn_recording.toggled.connect(self.updateRecording)

        btn_exit = QtGui.QPushButton('exit')
        btn_exit.clicked.connect(lambda:self.ExitApp())
        btn = QtGui.QPushButton('Update parameters')
        btn.clicked.connect(lambda: self.updateFromWindow(integration, sun_area_edit, comboBox, period))

        #btn.clicked.connect(lambda: (self.SC.setParameters(float(integration.text()), sun_area_edit.text(), comboBox.currentIndex())))

        mainLayout.addWidget(btn_exit)
        mainLayout.addWidget(QtGui.QLabel("Integration time (ms)"))
        mainLayout.addWidget(integration)
        mainLayout.addWidget(QtGui.QLabel("Gain (0 - 400)"))
        mainLayout.addWidget(gain)
        mainLayout.addWidget(QtGui.QLabel("Nazev pozorovani"))
        mainLayout.addWidget(sun_area_edit)
        mainLayout.addWidget(QtGui.QLabel("Typ dat"))
        mainLayout.addWidget(comboBox)
        mainLayout.addWidget(btn)
        mainLayout.addWidget(self.btn_recording)

        mainLayout.addWidget(QtGui.QLabel("Perioda ukladani (ms)"))
        mainLayout.addWidget(period)
        #mainLayout.addWidget(ploting)

        self.set_window.show()
        print "konec"

    def prepareViewWindow(self):

        self.view_window = QtGui.QWidget()
        #self.view_window.resize(250, 150)
        self.view_window.move(800, 300)
        self.view_window.setWindowTitle('SlitJaw')

        mainLayout = QtGui.QVBoxLayout()
        self.view_window.setLayout(mainLayout)

        self.view_window.setWindowFlags(QtCore.Qt.WindowTitleHint)
        self.view_window.setWindowFlags(QtCore.Qt.WindowStaysOnTopHint)

        self.canvas = QtGui.QLabel(self.view_window)
        self.pixmap = QtGui.QPixmap()
        #self.canvas.setPixmap(pixmap)

        #self.canvas = QtGui.QImage()
        mainLayout.addWidget(self.canvas)

        self.view_window.show()


    def updateRecording(self):
        self.SC.setRecording(self.btn_recording.isChecked())

    def updateFromWindow(self, integration, sun_area_edit, comboBox, period):
        self.SC.setParameters(float(integration.text()), sun_area_edit.text(), comboBox.currentIndex(), float(period.text()))

        rospy.set_param(self.node_name +"/cam_inegration", float(integration.text()))
        rospy.set_param(self.node_name +"/cam_data_type", int(comboBox.currentIndex()))
        #rospy.set_param(self.node_noma +"/cam_name", )
        rospy.set_param(self.node_name +"/cam_obsarea", str(sun_area_edit.text()) )

        #rosparam.dump_params(self.yaml_config_path, self.node_name)
        #print
        with open(self.yaml_config_path, 'w') as f:
            yaml.dump(rospy.get_param(self.node_name), f, default_flow_style=False)


    def setRecording(self, record = False):
        print "recording", record
        self.recording = record

    def setPlotting(self, plot = False):
        print "plotting", plot
        self.plot = plot


if __name__ == '__main__':
    m = slitjaw_cam()
